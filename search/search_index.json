{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Welcome to the beambusters documentation!"},{"location":"example/config/","title":"Configuration file","text":""},{"location":"example/config/#parameters-description","title":"Parameters description","text":"<p>The <code>config.yaml</code> file sets the configuration parameters of beambusters.</p> <p>geometry_file: Absolute path to the geometry file. Type: str.</p> <p>output_hdf5_root_path: Absolute path inside the hdf5 file to create a dataset with the output results. Type: str.</p> <p>chunks: Number of frames in a chunk for parallel processing. Type: int</p> <p>number_of_processors: Number of processors to use in parallel processing. Type: int.</p> <p>vds_format: True if the file is saved in VDS format. Type: bool.</p> <p>vds_id: Identification of which detector is being used. Currently it is supported <code>vds_spb_jf4m</code> and <code>generic</code>. Type: str.</p> <p>burst_mode: Indicate if the detector is on burst mode.</p> <p>state: Burst or storage cell mode (true) or single cell mode (false). Type: bool.</p> <p>storage_cell_hdf5_path: Absolute HDF5 path to the storage cell id per frame. Type: str</p> <p>plots:</p> <p>flag: Indicate if plots should be saved in intermediate steps (true) or not (false). Type: bool.</p> <p>maximum_number_of_frames: Number of frames to save plots. Type: int.</p> <p>file_name: The plots file name for saving. Type: str.</p> <p>folder_name: The plots folder name for saving. Type: str.</p> <p>root_path: Absolute path for the root directory for saving. Plots output are <code>/root_path/folder_name/*/file_name_*.png</code>. Type: str.</p> <p>value_auto: Control the automatic intensity adjustment of plots level (true). The normalization used is in logarithmic scale. Type: bool.</p> <p>value_min: If value_auto is false, minimum value of the intensity level should be passed. The normalization used is in logarithmic scale. Type: int.</p> <p>value_max: If value_auto is false, maximum value of the intensity level should be passed. The normalization used is in logarithmic scale. Type: int.</p> <p>axis_lim_auto: Control the automatic axis limits of the plots (true). Type: bool.</p> <p>xlim_min: If axis_lim_auto is false, minimum coordinate of the x axis should be passed. Type: int.</p> <p>xlim_max: If axis_lim_auto is false, maximum coordinate of the x axis should be passed. Type: int.</p> <p>ylim_min: If axis_lim_auto is false, minimum coordinate of the y axis should be passed. Type: int.</p> <p>ylim_max: If axis_lim_auto is false, maximum coordinate of the y axis should be passed. Type: int.</p> <p>color_map: Colormap preference for the plots, for example, viridis. Type: str.</p> <p>marker_size: Scatter marker size of center coordinates. Type: float.</p> <p>starting_frame: Change the index of the starting frame, it will jump the first n images of the container file. Type: int.</p> <p>force_center: Anchor the initial guess to a fixed point, if enabled this option will override other bblib pre-centering methods.</p> <p>state: Turn force mode on (true) or off (false). Type: bool.</p> <p>anchor_x: Turn force mode on (true) or off (false) for the x-axis. Type: bool.</p> <p>anchor_y: Turn force mode on (true) or off (false) for the y-axis. Type: bool.</p> <p>x: Initial guess pixel coordinates in x of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int.</p> <p>y: Initial guess pixel coordinates in y of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int.</p> <p>search_radius: Search radius used in the FriedelPairs bblib method. Type: float.</p> <p>pf8: peakfinder8 paratemers for Bragg peaks search. For more information, see the Cheetah Documentation.   min_num_peaks: Minimum number of peaks. Type: int.</p> <p>max_num_peaks: Maximum number of peaks. Type: int.</p> <p>adc_threshold: Arbitrary detector counts (ADC) threshold. Type: int.</p> <p>minimum_snr: Minimum signal-to-noise ratio (SNR). Type: float.</p> <p>min_pixel_count: Minimum number of pixels to consider a peak. Type: int.</p> <p>max_pixel_count: Maximum number of pixels to consider a peak. Type: int.</p> <p>local_bg_radius: Radius of the peaks local background, in pixels. Type: int.</p> <p>min_res: Minimum resolution region, in pixels. Type: int.</p> <p>max_res: Maximum resolution region, in pixels. Type: int.</p> <p>offset: Add an offset to the final calculated detector center.</p> <p>x: Offset in x direction, in pixels. Type: float.</p> <p>y: Offset in y direction, in pixels. Type: float.</p> <p>peak_region: Defines the approximate background peak distance from the center of the diffraction pattern, in pixels. This option is used in CircleDetection bblib pre-centering methods.</p> <p>min: Minimum distance, in pixels, of the background peak to the center of the diffraction pattern. Type: int.</p> <p>max: Maximum distance, in pixels, of the background peak to the center of the diffraction pattern. Type: int.</p> <p>outlier_distance: Don't refine the detector center with FriedelPairs method if the distance from the initial_guess (in a certain axis) to the reference_center coordinates is bigger than the outlier_distance.</p> <p>x: Outlier distance in x. Type: float.</p> <p>y: Outlier distance in y. Type: float.</p> <p>reference_center: Reference center of the diffraction pattern to filter outliers in the initial_guess calculation.</p> <p>x: Reference center pixel coordinates in x of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int.</p> <p>y: Reference center pixel coordinates in y of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int.</p> <p>canny: Controls skimage.feature.canny function, used in the CircleDetection bblib method. For more information, see the Scikit-image Documentation.</p> <p>sigma: Standard deviation of the Gaussian filter, used in the Canny function. Usually, 3 is good. Type: float.</p> <p>low_threshold: Lower bound for hysteresis thresholding (linking edges), as quantiles of the edge magnitude image. Threshold must be in the range [0, 1). Usually, 0.9 is good. Type: float.</p> <p>high_threshold: Upper bound for hysteresis thresholding (linking edges), as quantiles of the edge magnitude images. Threshold must be in the range [0, 1). Usually, 0.99 is good. Type: float.</p> <p>hough:</p> <p>maximum_rank: Test up until the nth peak of the Hough Space, in order of decreasing voting number. Type: int.</p> <p>outlier_distance: If the ranked solution (from the most voted to the less voted) is within the outlier shift in x and y this solution is chosen as the detector center.</p> <pre><code>x: Outlier shift in the x-axis. Type: int.\n\ny: Outlier shift in the y-axis. Type: int.\n</code></pre> <p>centering_method_for_initial_guess: Choose the bblib pre-centering method for the initial_guess assignment. The options available are <code>center_of_mass</code>, <code>circle_detection</code> or <code>manual_input</code>. Type: str.</p> <p>bragg_peaks_for_center_of_mass_calculation: Choose if Bragg peaks should be masked out (0) from the image in the CenterOfMass bblib method, or use only the Bragg peaks (1), or use the image as it is (-1). Type: int</p> <p>pixels_for_mask_of_bragg_peaks: Radius of the Bragg peaks, in pixels, to be masked in the pre-centering step. Type: int.</p> <p>grid_search_radius: Radius of the square grid search region (in pixels) around the initial guess used for the minimized peak FWHM centering method. Type: int.</p> <p>skip_centering_methods: List of bblib pre-centering methods to be skipped. Options: <code>center_of_mass</code>, <code>circle_detection</code> , <code>minimize_peak_fwhm</code> or <code>friedel_pairs</code>. Type: List[str]</p> <ul> <li>Method label you want to skip. Type: str.</li> </ul> <p>polarization: Configure the polarization correction before refining the center in the FridelPairs bblib method.</p> <p>apply_polarization_correction: Aoply polarization correction (true) or not (false). Type: bool</p> <p>axis: Polarization axis direction. Options: <code>x</code> and <code>y</code>, as defined by the CrystFEL referential convention. Type: str.</p> <p>value: Polarization fraction in the axis direction. Type: float.</p>"},{"location":"example/config/#configuration-file-example","title":"Configuration file example","text":"<pre><code>geometry_file: /path/to/geom/detector.geom\noutput_hdf5_root_path: /entry/data\n\nburst_mode:\n  is_active: false\n  storage_cell_hdf5_path: /entry/data/storage_cell_number\n\nchunks: 500\nnumber_of_processors: 16\n\nvds_format: true\nvds_id: generic\n\nplots:\n  flag: true\n  maximum_number_of_frames: 50\n  file_name: my_sample_label\n  folder_name: run_label\n  root_path: /path/to/plots\n  value_auto: false\n  value_min: 1e0\n  value_max: 5e2\n  axis_lim_auto: false\n  xlim_min: 200\n  xlim_max: 900\n  ylim_min: 200\n  ylim_max: 900\n  color_map: viridis\n  marker_size: 100\n\nforce_center:\n  state: false\n  anchor_x: true\n  anchor_y: false\n  x: 554\n  y: 522\n\nsearch_radius: 4.5\n\npf8:\n  min_num_peaks: 1\n  max_num_peaks: 10000\n  adc_threshold: 100\n  minimum_snr: 5\n  min_pixel_count: 2\n  max_pixel_count: 10000\n  local_bg_radius: 5\n  min_res: 0\n  max_res: 600\n\nstarting_frame: 500\n\npeak_region:\n  min: 50\n  max: 70\n\noutlier_distance:\n  x: 10\n  y: 100\n\nreference_center:\n  x: 554\n  y: 522\n\ncanny:\n  sigma: 3\n  low_threshold: 0.9\n  high_threshold: 0.99\n\nhough:\n  maximum_rank:\n  outlier_distance:\n    x: 10\n    y: 100\n\ncentering_method_for_initial_guess: circle_detection\n\nbragg_peaks_for_center_of_mass_calculation: -1\n\npixels_for_mask_of_bragg_peaks: 4\n\ngrid_search_radius: 5\n\nskip_centering_methods:\n  - center_of_mass\n\npolarization:\n  apply_polarization_correction: true\n  axis: x\n  value: 0.99\n</code></pre>"},{"location":"reference/","title":"About beambusters","text":"<p>Beambusters is an application developed to determine the detector center directly from still diffraction patterns collected in serial crystallography experiments.</p> <p>Beambusters uses the methods implemented in bblib to calculate the detector center shift in each diffraction pattern, according to your initial detector geometry (CrystFEL format).</p> <p>You can find more information about bblib on this page.</p>"},{"location":"reference/algorithms/","title":"Algorithms","text":"<p>This module defines the algorithms used to process the data.</p>"},{"location":"reference/algorithms/#beambusters.algorithms.calculate_detector_center_on_a_frame","title":"<code>calculate_detector_center_on_a_frame(calibrated_data, memory_cell_id, config, PF8Config)</code>","text":"<p>Calculate the detector center on a frame.</p> <p>Parameters:</p> Name Type Description Default <code>calibrated_data</code> <code>array</code> <p>The data in which the center determination will be performed.</p> required <code>memory_cell_id</code> <code>int</code> <p>The memory cell id of the frame, only necessary when operating in storage cell mode.</p> required <code>config</code> <code>dict</code> <p>A configuration dictionary in the format expected by beambusters.</p> required <code>PF8Config</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>list</code> <p>A list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined.</p> Source code in <code>beambusters/algorithms.py</code> <pre><code>def calculate_detector_center_on_a_frame(\n    calibrated_data: np.array, memory_cell_id: int, config: dict, PF8Config: PF8Info\n) -&gt; list:\n    \"\"\"\n    Calculate the detector center on a frame.\n\n    Args:\n        calibrated_data (np.array): The data in which the center determination will be performed.\n\n        memory_cell_id (int): The memory cell id of the frame, only necessary when operating in storage cell mode.\n\n        config (dict): A configuration dictionary in the format expected by beambusters.\n\n        PF8Config (PF8Info): Peakfinder8 parameters.\n\n    Returns:\n        results (list): A list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined.\n    \"\"\"\n    plots_info = {\"filename\": \"\", \"folder_name\": \"\", \"root_path\": \"\"}\n    config[\"plots_flag\"] = False\n\n    if \"center_of_mass\" not in config[\"skip_centering_methods\"]:\n        center_of_mass_method = CenterOfMass(\n            config=config, PF8Config=PF8Config, plots_info=plots_info\n        )\n        detector_center_from_center_of_mass = center_of_mass_method(\n            data=calibrated_data\n        )\n    else:\n        detector_center_from_center_of_mass = [-1, -1]\n    if \"circle_detection\" not in config[\"skip_centering_methods\"]:\n        for rank in range(config[\"hough\"][\"maximum_rank\"]):\n            config[\"hough_rank\"] = rank\n            circle_detection_method = CircleDetection(\n                config=config, PF8Config=PF8Config, plots_info=plots_info\n            )\n            detector_center_from_circle_detection = circle_detection_method(\n                data=calibrated_data\n            )\n\n            ## Calculate distance from the calculated center to the reference point in each axis\n            distance_in_x = math.sqrt(\n                (\n                    detector_center_from_circle_detection[0]\n                    - config[\"reference_center\"][\"x\"]\n                )\n                ** 2\n            )\n\n            distance_in_y = math.sqrt(\n                (\n                    detector_center_from_circle_detection[1]\n                    - config[\"reference_center\"][\"y\"]\n                )\n                ** 2\n            )\n\n            if (\n                distance_in_x &lt; config[\"hough\"][\"outlier_distance\"][\"x\"]\n                and distance_in_y &lt; config[\"hough\"][\"outlier_distance\"][\"y\"]\n            ):\n                break\n        ## Check for the case where rank reached the maximum value and the detector center is not within the allowed region\n        else:\n            detector_center_from_circle_detection = [-1, -1]\n    else:\n        detector_center_from_circle_detection = [-1, -1]\n    if \"minimize_peak_fwhm\" not in config[\"skip_centering_methods\"]:\n        minimize_peak_fwhm_method = MinimizePeakFWHM(\n            config=config, PF8Config=PF8Config, plots_info=plots_info\n        )\n        detector_center_from_minimize_peak_fwhm = minimize_peak_fwhm_method(\n            data=calibrated_data, initial_guess=detector_center_from_circle_detection\n        )\n    else:\n        detector_center_from_minimize_peak_fwhm = [-1, -1]\n\n    ## Define the initial_guess\n    initial_guess = [-1, -1]\n    pre_centering_flag = 0\n    is_a_hit = 0\n    refined_center_flag = 0\n\n    if config[\"centering_method_for_initial_guess\"] == \"center_of_mass\":\n        calculated_detector_center = detector_center_from_center_of_mass\n        distance_in_x = math.sqrt(\n            (calculated_detector_center[0] - config[\"reference_center\"][\"x\"]) ** 2\n        )\n        distance_in_y = math.sqrt(\n            (calculated_detector_center[1] - config[\"reference_center\"][\"y\"]) ** 2\n        )\n\n        if (\n            distance_in_x &lt; config[\"outlier_distance\"][\"x\"]\n            and distance_in_y &lt; config[\"outlier_distance\"][\"y\"]\n        ):\n            pre_centering_flag = 1\n            initial_guess = detector_center_from_center_of_mass\n    elif config[\"centering_method_for_initial_guess\"] == \"circle_detection\":\n        calculated_detector_center = detector_center_from_circle_detection\n        distance_in_x = math.sqrt(\n            (calculated_detector_center[0] - config[\"reference_center\"][\"x\"]) ** 2\n        )\n        distance_in_y = math.sqrt(\n            (calculated_detector_center[1] - config[\"reference_center\"][\"y\"]) ** 2\n        )\n        if (\n            distance_in_x &lt; config[\"outlier_distance\"][\"x\"]\n            and distance_in_y &lt; config[\"outlier_distance\"][\"y\"]\n        ):\n            pre_centering_flag = 1\n            initial_guess = detector_center_from_circle_detection\n    elif config[\"centering_method_for_initial_guess\"] == \"minimize_peak_fwhm\":\n        calculated_detector_center = detector_center_from_minimize_peak_fwhm\n        distance_in_x = math.sqrt(\n            (calculated_detector_center[0] - config[\"reference_center\"][\"x\"]) ** 2\n        )\n        distance_in_y = math.sqrt(\n            (calculated_detector_center[1] - config[\"reference_center\"][\"y\"]) ** 2\n        )\n\n        if (\n            distance_in_x &lt; config[\"outlier_distance\"][\"x\"]\n            and distance_in_y &lt; config[\"outlier_distance\"][\"y\"]\n        ):\n            pre_centering_flag = 1\n            initial_guess = detector_center_from_minimize_peak_fwhm\n    elif config[\"centering_method_for_initial_guess\"] == \"manual_input\":\n        initial_guess = [\n            config[\"manual_input\"][f\"{memory_cell_id}\"][\"x\"],\n            config[\"manual_input\"][f\"{memory_cell_id}\"][\"y\"],\n        ]\n\n    # If the method chosen didn't converge change to the detector center from the geometry file\n    if initial_guess[0] == -1 and initial_guess[1] == -1:\n        initial_guess = PF8Config.detector_center_from_geom\n\n    # Force center override the initial guess calculated to coordinates defined in config\n    if config[\"force_center\"][\"state\"]:\n        if config[\"force_center\"][\"anchor_x\"]:\n            initial_guess[0] = config[\"force_center\"][\"x\"]\n        if config[\"force_center\"][\"anchor_y\"]:\n            initial_guess[1] = config[\"force_center\"][\"y\"]\n\n    # Compares if the calculated center is within the outlier distance in each axis\n    distance_in_x = math.sqrt((initial_guess[0] - config[\"reference_center\"][\"x\"]) ** 2)\n    distance_in_y = math.sqrt((initial_guess[1] - config[\"reference_center\"][\"y\"]) ** 2)\n\n    # Start refine the detector center by FriedelPairs\n    center_is_refined = False\n\n    if (\n        distance_in_x &lt; config[\"outlier_distance\"][\"x\"]\n        and distance_in_y &lt; config[\"outlier_distance\"][\"y\"]\n    ):\n\n        ## Ready for detector center refinement\n        PF8Config.update_pixel_maps(\n            initial_guess[0] - PF8Config.detector_center_from_geom[0],\n            initial_guess[1] - PF8Config.detector_center_from_geom[1],\n        )\n        pf8 = PF8(PF8Config)\n        peak_list = pf8.get_peaks_pf8(data=calibrated_data)\n\n        if config[\"vds_format\"] and config[\"vds_id\"] == \"vds_spb_jf4m\":\n            geometry_filename = (\n                config[\"geometry_file\"].split(\".geom\")[0] + \"_hyperslab.geom\"\n            )\n        else:\n            geometry_filename = config[\"geometry_file\"]\n\n        PF8Config.set_geometry_from_file(geometry_filename)\n\n        if (\n            \"friedel_pairs\" not in config[\"skip_centering_methods\"]\n            and peak_list[\"num_peaks\"] &gt; config[\"pf8\"][\"min_num_peaks\"]\n        ):\n            is_a_hit = 1\n            friedel_pairs_method = FriedelPairs(\n                config=config, PF8Config=PF8Config, plots_info=plots_info\n            )\n            detector_center_from_friedel_pairs = friedel_pairs_method(\n                data=calibrated_data, initial_guess=initial_guess\n            )\n            if centering_converged(detector_center_from_friedel_pairs):\n                center_is_refined = True\n            else:\n                center_is_refined = False\n    else:\n        center_is_refined = False\n    ## Refined detector center assignement\n    if center_is_refined:\n        refined_detector_center = detector_center_from_friedel_pairs\n        refined_center_flag = 1\n    else:\n        refined_detector_center = initial_guess\n\n    # Global offset\n    if \"offset\" in config:\n        if \"x\" in config[\"offset\"]:\n            refined_detector_center[0] += config[\"offset\"][\"x\"]\n        if \"y\" in config[\"offset\"]:\n            refined_detector_center[1] += config[\"offset\"][\"y\"]\n\n    beam_position_shift_in_pixels = [\n        refined_detector_center[x] - PF8Config.detector_center_from_geom[x]\n        for x in range(2)\n    ]\n\n    detector_shift_in_mm = [\n        round(-1 * x * 1e3 / PF8Config.pixel_resolution, 4)\n        for x in beam_position_shift_in_pixels\n    ]\n    detector_shift_x_in_mm = detector_shift_in_mm[0]\n    detector_shift_y_in_mm = detector_shift_in_mm[1]\n\n    return [\n        detector_shift_x_in_mm,\n        detector_shift_y_in_mm,\n        is_a_hit,\n        pre_centering_flag,\n        refined_center_flag,\n    ]\n</code></pre>"},{"location":"reference/contact/","title":"Contact","text":"<p>Ana Carolina Rodrigues led the development of beambusters from 2021 to 2025 at the Deutsches Elektronen-Synchrotron (DESY) in Hamburg, Germany.</p> <p>For questions, please contact:</p> <p>Email: sc.anarodrigues@gmail.com</p>"},{"location":"reference/install/","title":"Installation","text":"<p>To install beambusters, run the following command in a terminal:</p> <pre><code>pip install beambusters\n</code></pre>"},{"location":"reference/main/","title":"main CLI","text":"<p>This module defines a Typer App for CLI usage.</p>"},{"location":"reference/main/#beambusters.main.main","title":"<code>main()</code>","text":"<p>This function perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame.</p> <p>Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat.</p> <p>For more information, type the following command:</p> <pre><code>beambusters run_centering --help\n</code></pre> Source code in <code>beambusters/main.py</code> <pre><code>@app.callback()\ndef main():\n    \"\"\"\n    This function perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame.\n\n    Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat.\n\n    For more information, type the following command:\n\n    ```bash\n    beambusters run_centering --help\n    ```\n\n    \"\"\"\n</code></pre>"},{"location":"reference/main/#beambusters.main.process_file","title":"<code>process_file(args)</code>","text":"<p>Process one event.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list</code> <p>A list of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path.</p> required <p>Returns:</p> Name Type Description <code>results</code> <code>list</code> <p>A list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined.</p> Source code in <code>beambusters/main.py</code> <pre><code>def process_file(args: list) -&gt; list:\n    \"\"\"\n    Process one event.\n\n    Args:\n        args (list): A list of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path.\n\n    Returns:\n        results (list): A list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined.\n\n    \"\"\"\n    data, memory_cell_id, path, config = args\n    filename, frame_number = path.split(\" //\")\n    print(f\"Image filename: {filename}\")\n    print(f\"Event: //{frame_number}\")\n    frame_number = int(frame_number)\n\n    PF8Config = settings.get_pf8_info(config)\n\n    # Transform vds to hyperslab\n    if len(data.shape) &gt; 2 and config[\"vds_format\"]:\n        calibrated_data = expand_data_to_hyperslab(\n            data=data, data_format=config[\"vds_id\"]\n        )\n        geometry_filename = (\n            config[\"geometry_file\"].split(\".geom\")[0] + \"_hyperslab.geom\"\n        )\n        if not os.path.exists(geometry_filename):\n            geometry_filename = translate_geom_to_hyperslab(config[\"geometry_file\"])\n    else:\n        calibrated_data = data\n        geometry_filename = config[\"geometry_file\"]\n\n    # PF8 processing\n    PF8Config.set_geometry_from_file(geometry_filename)\n    pf8 = PF8(PF8Config)\n    peak_list = pf8.get_peaks_pf8(data=calibrated_data)\n\n    if peak_list[\"num_peaks\"] &gt; config[\"pf8\"][\"min_num_peaks\"]:\n        result = calculate_detector_center_on_a_frame(\n            calibrated_data, memory_cell_id, config, PF8Config\n        )\n    else:\n        result = [0, 0, 0, 0, 0]\n    return result\n</code></pre>"},{"location":"reference/main/#beambusters.main.run_centering_parallel","title":"<code>run_centering_parallel(input_file, path_to_config)</code>","text":"<p>Process one HDF5 file. Results will be appended to the HDF5 file given as input file.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Full path to the HDF5 file.</p> required <code>path_to_config</code> <code>str</code> <p>Path to the YAML configuration file.</p> required Source code in <code>beambusters/main.py</code> <pre><code>@app.command(\"run_centering\")\ndef run_centering_parallel(input_file: str, path_to_config: str):\n    \"\"\"\n    Process one HDF5 file. Results will be appended to the HDF5 file given as input file.\n\n    Args:\n        input_file (str): Full path to the HDF5 file.\n\n        path_to_config (str): Path to the YAML configuration file.\n    \"\"\"\n    config = settings.read(path_to_config)\n    # BeambustersParam = settings.parse(config)\n    files = open(input_file, \"r\")\n    paths = files.readlines()\n    files.close()\n\n    if len(paths[0][:-1].split(\" //\")) == 1:\n        list_name = input_file\n        events_list_file = (\n            f\"{list_name.split('.')[0]}_events.lst{list_name.split('.lst')[-1]}\"\n        )\n        list_events(list_name, events_list_file, config[\"geometry_file\"])\n        files = open(events_list_file, \"r\")\n        paths = files.readlines()\n        files.close()\n\n    output_file, frame_number = paths[0].split(\" //\")\n    filename = output_file\n\n    geometry_txt = open(config[\"geometry_file\"], \"r\").readlines()\n    data_hdf5_path = [\n        x.split(\" = \")[-1][:-1] for x in geometry_txt if x.split(\" = \")[0] == \"data\"\n    ][0]\n\n    ## Initialize results array\n    number_of_frames = len(paths)\n    refined_center_flag = np.zeros(number_of_frames, dtype=np.int16)\n    pre_centering_flag = np.zeros(number_of_frames, dtype=np.int16)\n    hits = np.zeros((number_of_frames,), dtype=np.int16)\n    detector_shift_x_in_mm = np.zeros((number_of_frames,), dtype=np.float32)\n    detector_shift_y_in_mm = np.zeros((number_of_frames,), dtype=np.float32)\n\n    with h5py.File(f\"{filename}\", \"r\") as f:\n        data_shape = f[data_hdf5_path].shape\n    number_of_events = data_shape[0]\n    rest = number_of_events % config[\"chunks\"]\n    results = []\n\n    for i in range(0, number_of_events - rest, config[\"chunks\"]):\n        with h5py.File(f\"{filename}\", \"r\") as f:\n            events = np.array(\n                f[data_hdf5_path][i : i + config[\"chunks\"]], dtype=np.int32\n            )\n            if config[\"burst_mode\"][\"is_active\"]:\n                memory_cells_id = np.array(\n                    f[config[\"burst_mode\"][\"storage_cell_hdf5_path\"]][\n                        i : i + config[\"chunks\"]\n                    ],\n                    dtype=np.int32,\n                )\n            else:\n                memory_cells_id = np.zeros(config[\"chunks\"], dtype=np.int32)\n\n            # Use multiprocessing Pool for parallel processing\n            args = [\n                [event, memory_cells_id[index], paths[i + index], config]\n                for index, event in enumerate(events)\n            ]\n            with Pool(config[\"number_of_processors\"]) as p:\n                partial_results = p.map(process_file, args)\n            ## Join with results\n        results = [*results, *partial_results]\n\n    i = number_of_events - rest\n    with h5py.File(f\"{filename}\", \"r\") as f:\n        events = np.array(f[data_hdf5_path][i:number_of_events], dtype=np.int32)\n        if config[\"burst_mode\"][\"is_active\"]:\n            memory_cells_id = np.array(\n                f[config[\"burst_mode\"][\"storage_cell_hdf5_path\"]][i:number_of_events],\n                dtype=np.int32,\n            )\n        else:\n            memory_cells_id = np.zeros(rest, dtype=np.int32)\n        # Use multiprocessing Pool for parallel processing\n        args = [\n            [event, memory_cells_id[index], paths[index], config]\n            for index, event in enumerate(events)\n        ]\n        with Pool(config[\"number_of_processors\"]) as p:\n            partial_results = p.map(process_file, args)\n\n    results = [*results, *partial_results]\n\n    ## Rearrange results arrays\n    for index, i in enumerate(results):\n        (\n            detector_shift_x_in_mm[index],\n            detector_shift_y_in_mm[index],\n            hits[index],\n            pre_centering_flag[index],\n            refined_center_flag[index],\n        ) = i\n\n    with h5py.File(output_file, \"a\") as f:\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/detector_shift_x_in_mm\",\n            data=detector_shift_x_in_mm,\n        )\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/detector_shift_y_in_mm\",\n            data=detector_shift_y_in_mm,\n        )\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/refined_center_flag\",\n            data=refined_center_flag,\n        )\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/pre_centering_flag\",\n            data=pre_centering_flag,\n        )\n        f.create_dataset(f\"{config['output_hdf5_root_path']}/hit\", data=hits)\n</code></pre>"},{"location":"reference/settings/","title":"Settings","text":"<p>This module sets the configuration parameters from the YAML configuration file.</p>"},{"location":"reference/settings/#beambusters.settings.get_pf8_info","title":"<code>get_pf8_info(config)</code>","text":"<p>This function takes the peakfinder8 parameters from a config dictionary and parses them into a PF8Info object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary in the format expected by beambusters.</p> required <p>Returns:</p> Name Type Description <code>pf8info</code> <code>PF8Info</code> <p>Peakfinder8 parameters.</p> Source code in <code>beambusters/settings.py</code> <pre><code>def get_pf8_info(config: dict):\n    \"\"\"\n    This function takes the peakfinder8 parameters from a config dictionary and parses them into a PF8Info object.\n\n    Args:\n        config (dict): A configuration dictionary in the format expected by beambusters.\n\n    Returns:\n        pf8info (PF8Info): Peakfinder8 parameters.\n    \"\"\"\n    return PF8Info(\n        max_num_peaks=config[\"pf8\"][\"max_num_peaks\"],\n        adc_threshold=config[\"pf8\"][\"adc_threshold\"],\n        minimum_snr=config[\"pf8\"][\"minimum_snr\"],\n        min_pixel_count=config[\"pf8\"][\"min_pixel_count\"],\n        max_pixel_count=config[\"pf8\"][\"max_pixel_count\"],\n        local_bg_radius=config[\"pf8\"][\"local_bg_radius\"],\n        min_res=config[\"pf8\"][\"min_res\"],\n        max_res=config[\"pf8\"][\"max_res\"],\n    )\n</code></pre>"},{"location":"reference/settings/#beambusters.settings.parse","title":"<code>parse(config)</code>","text":"<p>This function receives the configuration dictionary loaded from the YAML and parse it into a flat dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>A configuration dictionary loaded from the YAML file.</p> required <p>Returns:</p> Name Type Description <code>config</code> <code>dict</code> <p>A configuration dictionary in a format expected by beambusters.</p> Source code in <code>beambusters/settings.py</code> <pre><code>def parse(config: dict) -&gt; dict:\n    \"\"\"\n    This function receives the configuration dictionary loaded from the YAML and parse it into a flat dictionary.\n\n    Args:\n        config (dict): A configuration dictionary loaded from the YAML file.\n\n    Returns:\n        config (dict): A configuration dictionary in a format expected by beambusters.\n    \"\"\"\n    return {\n        \"pf8_max_num_peaks\": config[\"pf8\"][\"max_num_peaks\"],\n        \"pf8_adc_threshold\": config[\"pf8\"][\"adc_threshold\"],\n        \"pf8_minimum_snr\": config[\"pf8\"][\"minimum_snr\"],\n        \"pf8_min_pixel_count\": config[\"pf8\"][\"min_pixel_count\"],\n        \"pf8_max_pixel_count\": config[\"pf8\"][\"max_pixel_count\"],\n        \"pf8_local_bg_radius\": config[\"pf8\"][\"local_bg_radius\"],\n        \"pf8_min_res\": config[\"pf8\"][\"min_res\"],\n        \"pf8_max_res\": config[\"pf8\"][\"max_res\"],\n        \"min_peak_region\": config[\"peak_region\"][\"min\"],\n        \"max_peak_region\": config[\"peak_region\"][\"max\"],\n        \"canny_sigma\": config[\"canny\"][\"sigma\"],\n        \"canny_low_thr\": config[\"canny\"][\"low_threshold\"],\n        \"canny_high_thr\": config[\"canny\"][\"high_threshold\"],\n        \"outlier_distance_in_x\": config[\"outlier_distance\"][\"x\"],\n        \"outlier_distance_in_y\": config[\"outlier_distance\"][\"y\"],\n        \"search_radius\": config[\"search_radius\"],\n        \"centering_method_for_initial_guess\": config[\n            \"centering_method_for_initial_guess\"\n        ],\n        \"bragg_peaks_positions_for_center_of_mass_calculation\": config[\n            \"bragg_peaks_positions_for_center_of_mass_calculation\"\n        ],\n        \"pixels_for_mask_of_bragg_peaks\": config[\"pixels_for_mask_of_bragg_peaks\"],\n        \"skipped_centering_methods\": config[\"skip_centering_methods\"],\n        \"polarization_apply\": config[\"polarization\"][\"apply_polarization_correction\"],\n        \"polarization_axis\": config[\"polarization\"][\"axis\"],\n        \"polarization_value\": config[\"polarization\"][\"value\"],\n        \"offset_x\": config[\"offset\"][\"x\"],\n        \"offset_y\": config[\"offset\"][\"y\"],\n        \"force_center_state\": config[\"force_center\"][\"state\"],\n        \"force_center\": [config[\"force_center\"][\"x\"], config[\"force_center\"][\"y\"]],\n        \"force_center_in_x\": config[\"force_center\"][\"anchor_x\"],\n        \"force_center_in_y\": config[\"force_center\"][\"anchor_y\"],\n        \"reference_center\": [\n            config[\"reference_center\"][\"x\"],\n            config[\"reference_center\"][\"y\"],\n        ],\n        \"geometry_file\": config[\"geometry_file\"],\n        \"parse_timestamp\": datetime.now().timestamp(),\n        \"burst_mode_active\": config[\"burst_mode\"][\"is_active\"],\n        \"vds_id\": config[\"vds_id\"],\n        \"plots_flag\": config[\"plots\"][\"flag\"],\n    }\n</code></pre>"},{"location":"reference/settings/#beambusters.settings.parse_plots_info","title":"<code>parse_plots_info(config)</code>","text":"<p>This function extracts plot parameters from a configuration dictionary and parses them into a flat dictionary of plot settings. Args:     config (dict): A configuration dictionary (in the format expected by beambusters).</p> <p>Returns:</p> Name Type Description <code>plots_info</code> <code>dict</code> <p>A dictionary containg the plot settings.</p> Source code in <code>beambusters/settings.py</code> <pre><code>def parse_plots_info(config: dict) -&gt; dict:\n    \"\"\"\n    This function extracts plot parameters from a configuration dictionary and parses them into a flat dictionary of plot settings.\n    Args:\n        config (dict): A configuration dictionary (in the format expected by beambusters).\n\n    Returns:\n        plots_info (dict): A dictionary containg the plot settings.\n    \"\"\"\n    return {\n        \"file_name\": config[\"plots\"][\"filename\"],\n        \"folder_name\": config[\"plots\"][\"folder_name\"],\n        \"root_path\": config[\"plots\"][\"root_path\"],\n        \"value_auto\": config[\"plots\"][\"value_auto\"],\n        \"value_max\": config[\"plots\"][\"value_max\"],\n        \"value_min\": config[\"plots\"][\"value_min\"],\n        \"axis_lim_auto\": config[\"plots\"][\"axis_lim_auto\"],\n        \"xlim_min\": config[\"plots\"][\"xlim_min\"],\n        \"xlim_max\": config[\"plots\"][\"xlim_max\"],\n        \"ylim_min\": config[\"plots\"][\"ylim_min\"],\n        \"ylim_max\": config[\"plots\"][\"ylim_max\"],\n        \"color_map\": config[\"plots\"][\"color_map\"],\n        \"marker_size\": config[\"plots\"][\"marker_size\"],\n    }\n</code></pre>"},{"location":"reference/settings/#beambusters.settings.read","title":"<code>read(path)</code>","text":"<p>This function reads a YAML configuration file from a specified path and loads it as a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the YAML configuration file.</p> required <p>Returns:</p> Name Type Description <code>config</code> <code>dict</code> <p>A configuration dictionary containing the information of the YAML configuration file.</p> Source code in <code>beambusters/settings.py</code> <pre><code>def read(path: str) -&gt; dict:\n    \"\"\"\n    This function reads a YAML configuration file from a specified path and loads it as a dictionary.\n\n    Args:\n        path (str): The path to the YAML configuration file.\n\n    Returns:\n        config (dict): A configuration dictionary containing the information of the YAML configuration file.\n    \"\"\"\n    path = Path(path)\n    config = path.read_text()\n    config = yaml.safe_load(config)\n    return config\n</code></pre>"},{"location":"reference/usage/","title":"Usage","text":"<p>To run beambusters, use the following command in your terminal:</p> <pre><code>beambusters run_centering /path/to/list/file /path/to/config/file\n</code></pre> <p>The configuration file uses the YAML format. An example of a configuration file can be found on this page.</p>"},{"location":"reference/utils/","title":"Utils","text":"<p>This module defines auxiliary funtions to process the data.</p>"},{"location":"reference/utils/#beambusters.utils.centering_converged","title":"<code>centering_converged(center)</code>","text":"<p>This function receives the detector center coordinates and checks if the centering converged.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>tuple</code> <p>Detector center coordinates determined by onxe of the bblib centering methods.</p> required <p>Returns:</p> Name Type Description <code>centering_flag</code> <code>bool</code> <p>True if the centering converged, False if the centering didn't converge.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def centering_converged(center: tuple) -&gt; bool:\n    \"\"\"\n    This function receives the detector center coordinates and checks if the centering converged.\n\n    Args:\n        center (tuple): Detector center coordinates determined by onxe of the bblib centering methods.\n\n    Returns:\n        centering_flag (bool): True if the centering converged, False if the centering didn't converge.\n    \"\"\"\n    if center[0] == -1 and center[1] == -1:\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.create_simple_vds","title":"<code>create_simple_vds(input_file, data_hdf5_path, output_file)</code>","text":"<p>This function shows an example how to create a file in the VDS format pointing a virtual dataset to a source. For European XFEL users there is a function in the Extra-data library to create VDS files of the measured runs.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the source file.</p> required <code>data_hdf5_path</code> <code>str</code> <p>HDF5 path to the data in the source file.</p> required <code>output_file</code> <code>str</code> <p>Path to the VDS file.</p> required Source code in <code>beambusters/utils.py</code> <pre><code>def create_simple_vds(input_file: str, data_hdf5_path: str, output_file: str):\n    \"\"\"\n    This function shows an example how to create a file in the VDS format pointing a virtual dataset to a source. For European XFEL users there is a function in the [Extra-data library](https://rtd.xfel.eu/docs/data-analysis-user-documentation/en/latest/software/hdf5-virtualise/#how-to-make-virtual-cxi-data-files) to create VDS files of the measured runs.\n\n    Args:\n        input_file (str): Path to the source file.\n\n        data_hdf5_path (str): HDF5 path to the data in the source file.\n\n        output_file (str): Path to the VDS file.\n\n    \"\"\"\n    with h5py.File(input_file, \"r\") as g:\n        shape = g[data_hdf5_path].shape\n        layouts = h5py.VirtualLayout(shape, dtype=np.int32)\n        vsrc = h5py.VirtualSource(input_file, data_hdf5_path, shape)\n        layouts[...] = vsrc\n\n    with h5py.File(output_file, \"w\", libver=(\"v110\", \"v110\")) as f:\n        f.create_dataset(\"cxi_version\", data=[150])\n        dgrp = f.create_group(\"entry/data\")\n        data = dgrp.create_virtual_dataset(\"data\", layouts)\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.expand_data_to_hyperslab","title":"<code>expand_data_to_hyperslab(data, data_format)</code>","text":"<p>This function takes the data in its original shape (VDS) and map each detector panel into the hyperslab that contains all detector panels in a single Numpy array.</p> <p>Supported detectors correspond to the Jungfrau 4M of the SPB/SFX instrument of the European XFEL (<code>vds_spb_jf4m</code>), see the Extra-geom Documentation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array</code> <p>Data array corresponding to one event.</p> required <code>data_format</code> <code>str</code> <p>Data format identification. Option: <code>vds_spb_jf4m</code>.</p> required <p>Returns:</p> Name Type Description <code>hyperslab</code> <code>array</code> <p>Data transformed from the original shape (VDS) to a single array containing all the detector panels.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def expand_data_to_hyperslab(data: np.array, data_format: str) -&gt; np.array:\n    \"\"\"\n    This function takes the data in its original shape (VDS) and map each detector panel into the hyperslab that contains all detector panels in a single Numpy array.\n\n    Supported detectors correspond to the Jungfrau 4M of the SPB/SFX instrument of the European XFEL (`vds_spb_jf4m`), see the [Extra-geom Documentation](https://extra-geom.readthedocs.io/en/latest/jungfrau_geometry.html).\n\n    Args:\n        data (np.array): Data array corresponding to one event.\n        data_format (str): Data format identification. Option: `vds_spb_jf4m`.\n\n    Returns:\n        hyperslab (np.array): Data transformed from the original shape (VDS) to a single array containing all the detector panels.\n    \"\"\"\n    if data_format == \"vds_spb_jf4m\":\n        hyperslab = np.zeros((2048, 2048), np.int32)\n        expected_shape = (8, 512, 1024)\n        if data.shape != expected_shape:\n            raise ValueError(\n                f\"Data shape for {data_format} format not in expected shape: {expected_shape}.\"\n            )\n    else:\n        raise NameError(\"Unknown data format.\")\n\n    ## Concatenate panels in one hyperslab keep the order break after panel 4 to second column, as described here: https://extra-geom.readthedocs.io/en/latest/jungfrau_geometry.html.\n    for panel_id, panel in enumerate(data):\n        if panel_id &lt; 4:\n            hyperslab[512 * panel_id : 512 * (panel_id + 1), 0:1024] = panel\n        else:\n            if panel_id == 4:\n                hyperslab[512 * (-panel_id + 3) :, 1024:2048] = panel\n            else:\n                hyperslab[512 * (-panel_id + 3) : 512 * (-panel_id + 4), 1024:2048] = (\n                    panel\n                )\n\n    return hyperslab\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.get_500k_slab","title":"<code>get_500k_slab(slab_name, offset_ss, offset_fs)</code>","text":"<p>This function creates a Jungfrau panel of 500k pixels with the first pixel (of the first row) positioned at the upper-left corner of the slab. The panel can be translated from the origin by specifying offsets along the slow-scan and fast-scan axes.</p> <p>Parameters:</p> Name Type Description Default <code>slab_name</code> <code>str</code> <p>Identification of the panel or slab.</p> required <code>offset_ss</code> <code>int</code> <p>Number of indices to offset the panel along the slow-scan axis.</p> required <code>offset_fs</code> <code>int</code> <p>Number of indices to offset the panel along the fast-scan axis.</p> required <p>Returns:</p> Name Type Description <code>panel</code> <code>dict</code> <p>A dictionary containg the panel identification and its slow-scan and fast-scan limits in the hyperslab.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def get_500k_slab(slab_name: str, offset_ss: int, offset_fs: int) -&gt; dict:\n    \"\"\"\n    This function creates a Jungfrau panel of 500k pixels with the first pixel (of the first row) positioned at the upper-left corner of the slab. The panel can be translated from the origin by specifying offsets along the slow-scan and fast-scan axes.\n\n    Args:\n        slab_name (str): Identification of the panel or slab.\n        offset_ss (int): Number of indices to offset the panel along the slow-scan axis.\n        offset_fs (int): Number of indices to offset the panel along the fast-scan axis.\n\n    Returns:\n        panel (dict): A dictionary containg the panel identification and its slow-scan and fast-scan limits in the hyperslab.\n    \"\"\"\n    return {\n        f\"{slab_name}\": {\n            \"a1\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 768 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 1023 + offset_fs,\n            },\n            \"a2\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 512 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 767 + offset_fs,\n            },\n            \"a3\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 256 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 511 + offset_fs,\n            },\n            \"a4\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 0 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 255 + offset_fs,\n            },\n            \"a5\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 768 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 1023 + offset_fs,\n            },\n            \"a6\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 512 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 767 + offset_fs,\n            },\n            \"a7\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 256 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 511 + offset_fs,\n            },\n            \"a8\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 0 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 255 + offset_fs,\n            },\n        }\n    }\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.get_500k_slab_inverted","title":"<code>get_500k_slab_inverted(slab_name, offset_ss, offset_fs)</code>","text":"<p>This function creates a Jungfrau panel of 500k pixels with the first pixel (of the first row) positioned at the bottom-right corner of the slab. The panel can be translated from the origin by specifying offsets along the slow-scan and fast-scan axes.</p> <p>Parameters:</p> Name Type Description Default <code>slab_name</code> <code>str</code> <p>Identification of the panel or slab.</p> required <code>offset_ss</code> <code>int</code> <p>Number of indices to offset the panel along the slow-scan axis.</p> required <code>offset_fs</code> <code>int</code> <p>Number of indices to offset the panel along the fast-scan axis.</p> required <p>Returns:</p> Name Type Description <code>panel</code> <code>dict</code> <p>A dictionary containg the panel identification and its slow-scan and fast-scan limits in the hyperslab.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def get_500k_slab_inverted(slab_name: str, offset_ss: int, offset_fs: int) -&gt; dict:\n    \"\"\"\n    This function creates a Jungfrau panel of 500k pixels with the first pixel (of the first row) positioned at the bottom-right corner of the slab. The panel can be translated from the origin by specifying offsets along the slow-scan and fast-scan axes.\n\n    Args:\n        slab_name (str): Identification of the panel or slab.\n        offset_ss (int): Number of indices to offset the panel along the slow-scan axis.\n        offset_fs (int): Number of indices to offset the panel along the fast-scan axis.\n\n    Returns:\n        panel (dict): A dictionary containg the panel identification and its slow-scan and fast-scan limits in the hyperslab.\n\n    \"\"\"\n    return {\n        f\"{slab_name}\": {\n            \"a1\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 0 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 255 + offset_fs,\n            },\n            \"a2\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 256 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 511 + offset_fs,\n            },\n            \"a3\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 512 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 767 + offset_fs,\n            },\n            \"a4\": {\n                \"min_ss\": 0 + offset_ss,\n                \"min_fs\": 768 + offset_fs,\n                \"max_ss\": 255 + offset_ss,\n                \"max_fs\": 1023 + offset_fs,\n            },\n            \"a5\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 0 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 255 + offset_fs,\n            },\n            \"a6\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 256 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 511 + offset_fs,\n            },\n            \"a7\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 512 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 767 + offset_fs,\n            },\n            \"a8\": {\n                \"min_ss\": 256 + offset_ss,\n                \"min_fs\": 768 + offset_fs,\n                \"max_ss\": 511 + offset_ss,\n                \"max_fs\": 1023 + offset_fs,\n            },\n        }\n    }\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.get_slab_coordinates_in_hyperslab","title":"<code>get_slab_coordinates_in_hyperslab(slab_name, asic_name, key, detector_layout)</code>","text":"<p>This function return the value of a key (<code>min_ss</code>, <code>max_ss</code>, <code>min_fs</code> or <code>max_fs</code>) from one detector layout dictionary, a slab identification and an asic identification.</p> <p>Returns:</p> Name Type Description <code>value</code> <code>int</code> <p>Value of the slow-scan and fast-scan limits in the hyperslab for a given detector layout, panel and asic.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def get_slab_coordinates_in_hyperslab(\n    slab_name: str, asic_name: str, key: str, detector_layout: dict\n) -&gt; int:\n    \"\"\"\n    This function return the value of a key (`min_ss`, `max_ss`, `min_fs` or `max_fs`) from one detector layout dictionary, a slab identification and an asic identification.\n\n    Returns:\n        value (int): Value of the slow-scan and fast-scan limits in the hyperslab for a given detector layout, panel and asic.\n    \"\"\"\n\n    return detector_layout[f\"{slab_name}\"][f\"{asic_name}\"][f\"{key}\"]\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.image_expand_frames","title":"<code>image_expand_frames(data_hdf5_path, file_name)</code>","text":"<p>Expands the events of an HDF5 file by specifying the HDF5 path to the data.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>Path to the HDF5 file.</p> required <code>data_hdf5_path</code> <code>str</code> <p>Path pointing to the data in the HDF5 file.</p> required <p>Returns:</p> Name Type Description <code>events_list</code> <code>ndarray</code> <p>Array containing the number each listed event.</p> <code>num_events</code> <code>int</code> <p>Total number of events in the HDF5 file.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def image_expand_frames(data_hdf5_path: str, file_name: str) -&gt; tuple:\n    \"\"\"\n    Expands the events of an HDF5 file by specifying the HDF5 path to the data.\n\n    Args:\n        file_name (str): Path to the HDF5 file.\n        data_hdf5_path (str): Path pointing to the data in the HDF5 file.\n\n    Returns:\n        events_list (np.ndarray): Array containing the number each listed event.\n\n        num_events (int): Total number of events in the HDF5 file.\n    \"\"\"\n    with h5py.File(f\"{file_name}\", \"r\") as f:\n        num_events = (f[data_hdf5_path]).shape[0]\n\n    events_list = np.arange(0, num_events, 1)\n\n    return events_list, num_events\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.list_events","title":"<code>list_events(input_file, output_file, geometry_file)</code>","text":"<p>Expands a list of filenames into a list of individual events. Similar to the list_events in CrystFEL.</p> <p>Parameters:</p> Name Type Description Default <code>input_file</code> <code>str</code> <p>Path to the file list containg the data filename.</p> required <code>output_file</code> <code>str</code> <p>Path to the output file list containing the individual events path.</p> required <code>geometry_file</code> <code>str</code> <p>Path to the geometry file in CrystFEL format.</p> required Source code in <code>beambusters/utils.py</code> <pre><code>def list_events(input_file: str, output_file: str, geometry_file: str):\n    \"\"\"\n    Expands a list of filenames into a list of individual events. Similar to the [list_events](https://www.desy.de/~twhite/crystfel/manual-list_events.html#:~:text=list_events%20expands%20a%20list%20of,than%20just%20processing%20all%20events.) in CrystFEL.\n\n    Args:\n        input_file (str): Path to the file list containg the data filename.\n        output_file (str): Path to the output file list containing the individual events path.\n        geometry_file (str): Path to the geometry file in CrystFEL format.\n\n    \"\"\"\n\n    geometry_txt = open(geometry_file, \"r\").readlines()\n    data_hdf5_path = [\n        x.split(\" = \")[-1][:-1] for x in geometry_txt if x.split(\" = \")[0] == \"data\"\n    ][0]\n\n    with open(input_file, \"r\") as ifh, open(output_file, \"w\") as ofh:\n        if data_hdf5_path is None:\n            print(f\"ERROR: Failed to read '{geometry_file}'\", file=sys.stderr)\n            sys.exit(1)\n\n        for file_name in ifh:\n            file_name = file_name.strip()\n            if file_name:\n                events_list, num_events = image_expand_frames(data_hdf5_path, file_name)\n                if events_list is None:\n                    print(f\"ERROR: Failed to read {file_name}\", file=sys.stderr)\n                    sys.exit(1)\n\n                for event in events_list:\n                    ofh.write(f\"{file_name} //{event}\\n\")\n\n                print(f\"{num_events} events found in {file_name}\")\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.reduce_hyperslab_to_vds","title":"<code>reduce_hyperslab_to_vds(data, data_format)</code>","text":"<p>This function takes the data in the hyperslab shape and reduce it to the original shape (VDS).</p> <p>Supported detector is the Jungfrau 4M of the SPB/SFX instrument of the European XFEL (<code>vds_spb_jf4m</code>), see the Extra-geom Documentation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>array</code> <p>Data array in the hyperslab shape.</p> required <code>data_format</code> <code>str</code> <p>Data format identification. Option: <code>vds_spb_jf4m</code>.</p> required <p>Returns:</p> Name Type Description <code>vds_slab</code> <code>array</code> <p>Data transformed from the hyperslab shape to the original shape (VDS).</p> Source code in <code>beambusters/utils.py</code> <pre><code>def reduce_hyperslab_to_vds(data: np.array, data_format: str) -&gt; np.array:\n    \"\"\"\n    This function takes the data in the hyperslab shape and reduce it to the original shape (VDS).\n\n    Supported detector is the Jungfrau 4M of the SPB/SFX instrument of the European XFEL (`vds_spb_jf4m`), see the [Extra-geom Documentation](https://extra-geom.readthedocs.io/en/latest/jungfrau_geometry.html).\n\n    Args:\n        data (np.array): Data array in the hyperslab shape.\n        data_format (str): Data format identification. Option: `vds_spb_jf4m`.\n\n    Returns:\n        vds_slab (np.array): Data transformed from the hyperslab shape to the original shape (VDS).\n\n    \"\"\"\n    if data_format == \"vds_spb_jf4m\":\n        expected_shape = (2048, 2048)\n        vds_slab = np.zeros((1, 8, 512, 1024), np.int32)\n        if data.shape != expected_shape:\n            raise ValueError(\n                f\"Data shape for {data_format} format not in expected shape: {expected_shape}.\"\n            )\n    else:\n        raise NameError(\"Unknown data format.\")\n\n    ## Concatenate panels in one hyperslab keep the order break after panel 4 to second column, as described here: https://extra-geom.readthedocs.io/en/latest/jungfrau_geometry.html.\n    jf_4m_matrix = [[1, 8], [2, 7], [3, 6], [4, 5]]\n\n    for j in range(0, 2048, 1024):\n        for i in range(0, 2048, 512):\n            panel_number = jf_4m_matrix[int(i / 512)][int(j / 1024)]\n            vds_slab[0, panel_number - 1, :] = data[i : i + 512, j : j + 1024]\n\n    return vds_slab\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.slab_to_hyperslab","title":"<code>slab_to_hyperslab()</code>","text":"<p>Creates a dictionary containing all the panels of the detector and their corresponding slow-scan and fast-scan axis limits in the hyperslab.</p> <p>Returns:</p> Name Type Description <code>jf_4m_in_hyperslab</code> <code>dict</code> <p>A dictionary containg the panels of the Jungfrau 4M of the SPB/SFX instrument of the European XFEL, see the Extra-geom Documentation.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def slab_to_hyperslab() -&gt; dict:\n    \"\"\"\n    Creates a dictionary containing all the panels of the detector and their corresponding slow-scan and fast-scan axis limits in the hyperslab.\n\n    Returns:\n        jf_4m_in_hyperslab (dict): A dictionary containg the panels of the Jungfrau 4M of the SPB/SFX instrument of the European XFEL, see the [Extra-geom Documentation](https://extra-geom.readthedocs.io/en/latest/jungfrau_geometry.html).\n    \"\"\"\n    jf_4m_in_hyperslab = {}\n    slab_name = \"p1\"\n    jf_4m_in_hyperslab.update(get_500k_slab(slab_name, 0, 0))\n    slab_name = \"p2\"\n    jf_4m_in_hyperslab.update(get_500k_slab(slab_name, 512, 0))\n    slab_name = \"p3\"\n    jf_4m_in_hyperslab.update(get_500k_slab(slab_name, 1024, 0))\n    slab_name = \"p4\"\n    jf_4m_in_hyperslab.update(get_500k_slab(slab_name, 1536, 0))\n    slab_name = \"p5\"\n    jf_4m_in_hyperslab.update(get_500k_slab_inverted(slab_name, 1536, 1024))\n    slab_name = \"p6\"\n    jf_4m_in_hyperslab.update(get_500k_slab_inverted(slab_name, 1024, 1024))\n    slab_name = \"p7\"\n    jf_4m_in_hyperslab.update(get_500k_slab_inverted(slab_name, 512, 1024))\n    slab_name = \"p8\"\n    jf_4m_in_hyperslab.update(get_500k_slab_inverted(slab_name, 0, 1024))\n\n    return jf_4m_in_hyperslab\n</code></pre>"},{"location":"reference/utils/#beambusters.utils.translate_geom_to_hyperslab","title":"<code>translate_geom_to_hyperslab(geometry_filename)</code>","text":"<p>Translates the geometry file (CrystFEL format), written for data in the original shape (VDS), to perform the same operations in the panels when using the data in the hyperslab shape.</p> <p>Supported detector is the Jungfrau 4M of the SPB/SFX instrument of the European XFEL (<code>vds_spb_jf4m</code>), see the Extra-geom Documentation.</p> <p>Parameters:</p> Name Type Description Default <code>geometry_filename</code> <code>str</code> <p>Path to the geometry file in CrystFEL format.</p> required <p>Returns:</p> Name Type Description <code>output_filename</code> <code>str</code> <p>Path to the geometry file, in CrystFEL format, for operating the hyperslab.</p> Source code in <code>beambusters/utils.py</code> <pre><code>def translate_geom_to_hyperslab(geometry_filename: str) -&gt; str:\n    \"\"\"\n    Translates the geometry file (CrystFEL format), written for data in the original shape (VDS), to perform the same operations in the panels when using the data in the hyperslab shape.\n\n    Supported detector is the Jungfrau 4M of the SPB/SFX instrument of the European XFEL (`vds_spb_jf4m`), see the [Extra-geom Documentation](https://extra-geom.readthedocs.io/en/latest/jungfrau_geometry.html).\n\n    Args:\n        geometry_filename (str): Path to the geometry file in CrystFEL format.\n\n    Returns:\n        output_filename (str): Path to the geometry file, in CrystFEL format, for operating the hyperslab.\n    \"\"\"\n    input_file = open(geometry_filename, \"r\")\n    lines = input_file.readlines()\n    input_file.close()\n\n    output_filename = geometry_filename.split(\".geom\")[0] + \"_hyperslab.geom\"\n\n    jf_4m_hyperslab = slab_to_hyperslab()\n\n    f = open(output_filename, \"w\")\n\n    for line in lines:\n        key = line.split(\"=\")[0]\n        key_parts = key.split(\"/\")\n        if len(key_parts) &gt; 1 and key_parts[1] in (\n            \"min_ss \",\n            \"min_fs \",\n            \"max_ss \",\n            \"max_fs \",\n        ):\n            slab_id = key_parts[0].split(\"a\")[0]\n            asic_id = key_parts[0].split(slab_id)[-1]\n            new_value = get_slab_coordinates_in_hyperslab(\n                slab_name=slab_id,\n                asic_name=asic_id,\n                key=key_parts[1][:-1],\n                detector_layout=jf_4m_hyperslab,\n            )\n            f.write(f\"{key} = {new_value}\\n\")\n        else:\n            f.write(line)\n    f.close()\n    return output_filename\n</code></pre>"}]}