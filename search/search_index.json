{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to beambusters!</p>"},{"location":"example/config/","title":"Configuration","text":"<p>The <code>config.yaml</code> file sets the configuration parameters of beambusters.</p> <p>geometry_file: Absolute path to the geometry file. Type: str</p> <p>output_hdf5_root_path: Absolute path inside the hdf5 file to create a dataset with the output results. Type: str</p> <p>chunks: Number of frames in a chunk for parallel processing</p> <p>number_of_processors: Number of processors to use in parallel processing</p> <p>vds_format: True if the file is saved in VDS format. Type: bool</p> <p>vds_id: Identification of which detector is being used. Currently it is supported \"vds_spb_jf4m\" and \"generic\". Type: str</p> <p>burst_mode: Indicate if the detector is on burst mode.</p> <p>state: Burst/storage cell mode (true) or single cell mode (false). Type: bool.</p> <p>storage_cell_hdf5_path: Absolute HDF5 path to the storage cell id per frame. Type: str</p> <p>plots:</p> <p>flag: Indicate if plots should be saved in intermediate steps (true) or not (false). Type: bool.</p> <p>maximum_number_of_frames: Number of frames to save plots. Type: int</p> <p>file_name: The plots file name for saving. Type: str.</p> <p>folder_name: The plots folder name for saving. Type: str.</p> <p>root_path: Absolute path for the root directory for saving. Plots final state is /root_path/folder_name//file_name_.png. Type: str.</p> <p>value_auto: Control the automatic intensity adjustment of plots level (true). The normalization used is in logarithmic scale. Type: bool.</p> <p>value_min: If value_auto is false, minimum value of the intensity level should be passed. The normalization used is in logarithmic scale. Type: int.</p> <p>value_max: If value_auto is false, maximum value of the intensity level should be passed. The normalization used is in logarithmic scale. Type: int.</p> <p>axis_lim_auto: Control the automatic axis limits of the plots (true). Type: bool.</p> <p>xlim_min: If axis_lim_auto is false, minimum coordinate of the x axis should be passed. Type: int.</p> <p>xlim_max: If axis_lim_auto is false, maximum coordinate of the x axis should be passed. Type: int.</p> <p>ylim_min: If axis_lim_auto is false, minimum coordinate of the y axis should be passed. Type: int.</p> <p>ylim_max: If axis_lim_auto is false, maximum coordinate of the y axis should be passed. Type: int.</p> <p>color_map: Colormap preference for the plots, for example: viridis. Type: str.   marker_size: Scatter marker size of center coordinates. Type: float</p> <p>starting_frame: Change the index of the starting frame, it will jump the first n images of the container file. Type: int.</p> <p>force_center: Anchor the initial guess to a fixed point, if enabled this option will override other bblib pre-centering methods.</p> <p>state: Turn force mode on (true) or off (false). Type: bool.</p> <p>anchor_x: Turn force mode on (true) or off (false) for the x-axis. Type: bool.</p> <p>anchor_y: Turn force mode on (true) or off (false) for the y-axis . Type: bool.</p> <p>x: Initial guess pixel coordinates in x of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int.</p> <p>y: Initial guess pixel coordinates in y of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int.</p> <p>search_radius: Search radius used in the FriedelPairs bblib method. Type: float</p> <p>pf8: peakfinder8 paratemers for Bragg peaks search. For more information, see: https://www.desy.de/~barty/cheetah/Cheetah/SFX_hitfinding.html</p> <p>max_num_peaks: Maximum number of peaks. Type: int</p> <p>adc_threshold: Arbitrary detector counts (ADC) threshold. Type: int</p> <p>minimum_snr: Minimum signal-to-noise ratio (SNR). Type: float</p> <p>min_pixel_count: Minimum number of pixels to consider a peak. Type: int</p> <p>max_pixel_count: Maximum number of pixels to consider a peak. Type: int</p> <p>local_bg_radius: Radius of the peaks local background, in pixels. Type: int</p> <p>min_res: Minimum resolution region, in pixels. Type: int</p> <p>max_res: Maximum resolution region, in pixels. Type: int</p> <p>offset: Add an offset to the calculated center. The offset will be applied in the end of every bblib centering method. Set offsets to +0.5 in x and y to shift the detector center coordinates from pixel indices to the pixel center, as expected for CrystFEL.</p> <p>x: Offset in x direction, in pixels. Type: int</p> <p>y: Offset in y direction, in pixels. Type: int</p> <p>peak_region: Defines the approximate background peak distance from the center of the diffraction pattern, in pixels. This option is used in CircleDetection bblib pre-centering methods.</p> <p>min: Minimum distance, in pixels, of the background peak to the center of the diffraction pattern. Type: int</p> <p>max: Maximum distance, in pixels, of the background peak to the center of the diffraction pattern. Type: int</p> <p>outlier_distance: Don't refine the detector center with FriedelPairs method if the distance from the initial_guess (in a certain axis) to the reference_center coordinates is bigger than the outlier_distance.</p> <p>x: Outlier distance in x</p> <p>y: Outlier distance in y</p> <p>reference_center: Reference center of the diffraction pattern to filter outliers in the initial_guess calculation</p> <p>x: Reference center pixel coordinates in x of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int</p> <p>y: Reference center pixel coordinates in y of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int</p> <p>canny: Controls skimage.feature.canny function, used in the CircleDetection bblib method. For more information, see: https://scikit-image.org/docs/stable/auto_examples/edges/plot_circular_elliptical_hough_transform.html</p> <p>sigma: Standard deviation of the Gaussian filter, used in the Canny function. Usually, 3 is good. Type: float</p> <p>low_threshold: Lower bound for hysteresis thresholding (linking edges), as quantiles of the edge magnitude image. Threshold must be in the range [0, 1). Usually, 0.9 is good. Type: float</p> <p>high_threshold: Upper bound for hysteresis thresholding (linking edges), as quantiles of the edge magnitude images. Threshold must be in the range [0, 1). Usually, 0.99 is good. Type: float</p> <p>hough:</p> <p>maximum_rank: Evaluate the ranked solutions of Hough transform output until the   maximum ranked position.</p> <p>outlier_distance: If the ranked solution (from the most voted to the less voted) is within the outlier shift in x and y this solution is chosen as the detector center.     x: Outlier shift in the x-axis     y: Outlier shift in the y-axis</p> <p>centering_method_for_initial_guess: Choose the bblib pre-centering method for the</p> <p>initial_guess assignment. Options: 'center_of_mass' or 'circle_detection'. Type: str</p> <p>bragg_peaks_positions_for_center_of_mass_calculation: Choose if Bragg peaks should be masked out (0) from the image in the CenterOfMass bblib method, or use only the Bragg peaks (1), or use the image as it is (-1). Type: int</p> <p>pixels_for_mask_of_bragg_peaks: Radius of Bragg peaks, in pixels. Used in the bblib</p> <p>pre-centering methods. Type: int</p> <p>skip_centering_methods: List of bblib pre-centering methods you don't want to be executed. Options: 'center_of_mass', 'circle_detection' or 'friedel_pairs'. Type: List[str]</p> <ul> <li>Method label you want to skip. Type: str</li> </ul> <p>polarization: Configure the polarization correction before refining the center in the FridelPairs bblib method.</p> <p>apply_polarization_correction: Aoply polarization correction (true) or not (false). Type: bool</p> <p>axis: Polarization axis direction. Options: 'x' and 'y', as defined by the CrystFEL referential convention. Type: str</p> <p>value: Polarization fraction in the axis direction. Type: float</p>"},{"location":"example/config/#example","title":"Example","text":"<pre><code>geometry_file: /path/to/geom/detector.geom\noutput_hdf5_root_path: /entry/data\n\nburst_mode:\n  is_active: false\n  storage_cell_hdf5_path: /entry/data/storage_cell_number\n\nchunks: 500\nnumber_of_processors: 16\n\nvds_format: true\nvds_id: generic\n\nplots:\n  flag: true\n  maximum_number_of_frames: 50\n  file_name: my_sample_label\n  folder_name: run_label\n  root_path: /path/to/plots\n  value_auto: false\n  value_min: 1e0\n  value_max: 5e2\n  axis_lim_auto: false\n  xlim_min: 200\n  xlim_max: 900\n  ylim_min: 200\n  ylim_max: 900\n  color_map: viridis\n  marker_size: 100\n\nforce_center:\n  state: false\n  anchor_x: true\n  anchor_y: false\n  x: 554\n  y: 522\n\nsearch_radius: 4.5\n\npf8:\n  max_num_peaks: 10000\n  adc_threshold: 100\n  minimum_snr: 5\n  min_pixel_count: 2\n  max_pixel_count: 10000\n  local_bg_radius: 5\n  min_res: 0\n  max_res: 600\n\nstarting_frame: 500\n\noffset:\n  x: 0.5\n  y: 0.5\n\npeak_region:\n  min: 50\n  max: 70\n\noutlier_distance:\n  x: 10\n  y: 100\n\nreference_center:\n  x: 554\n  y: 522\n\ncanny:\n  sigma: 3\n  low_threshold: 0.9\n  high_threshold: 0.99\n\nhough:\n  maximum_rank:\n  outlier_distance:\n    x: 10\n    y: 100\n\ncentering_method_for_initial_guess: circle_detection\n\nbragg_peaks_positions_for_center_of_mass_calculation: -1\n\npixels_for_mask_of_bragg_peaks: 4\n\nskip_centering_methods:\n  - minimize_peak_fwhm\n\npolarization:\n  apply_polarization_correction: true\n  axis: x\n  value: 0.99\n</code></pre>"},{"location":"reference/","title":"About beambusters","text":"<p>Welcome to the Beambusters Documentation.</p>"},{"location":"reference/main/","title":"main CLI","text":""},{"location":"reference/main/#beambusters.main","title":"<code>main</code>","text":"<p>This module defines a Typer App for CLI usage.</p>"},{"location":"reference/main/#beambusters.main.main","title":"<code>main()</code>","text":"<p>This function perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame.</p> <p>Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat.</p> <p>For more information, type the following command:</p> <p>beambusters run_centering --help</p> Source code in <code>beambusters/main.py</code> <pre><code>@app.callback()\ndef main():\n    \"\"\"\n    This function perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame.\n\n    Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat.\n\n    For more information, type the following command:\n\n    beambusters run_centering --help\n    \"\"\"\n</code></pre>"},{"location":"reference/main/#beambusters.main.process_file","title":"<code>process_file(args)</code>","text":"<p>Process one event.</p> <p>Attributes:</p> Name Type Description <code>args</code> <code>list</code> <p>List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path.</p> <p>Returns:</p> Name Type Description <code>results</code> <code>list</code> <p>Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined.</p> Source code in <code>beambusters/main.py</code> <pre><code>def process_file(args: list) -&gt; list:\n    \"\"\"\n    Process one event.\n\n    Attributes:\n        args (list): List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path.\n\n    Returns:\n        results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined.\n\n    \"\"\"\n    data, memory_cell_id, path, config = args\n    filename, frame_number = path.split(\" //\")\n    print(f\"Image filename: {filename}\")\n    print(f\"Event: //{frame_number}\")\n    frame_number = int(frame_number)\n\n    PF8Config = settings.get_pf8_info(config)\n\n    # Transform vds to hyperslab\n    if len(data.shape) &gt; 2 and config[\"vds_format\"]:\n        calibrated_data = expand_data_to_hyperslab(\n            data=data, data_format=config[\"vds_id\"]\n        )\n        geometry_filename = (\n            config[\"geometry_file\"].split(\".geom\")[0] + \"_hyperslab.geom\"\n        )\n        if not os.path.exists(geometry_filename):\n            geometry_filename = translate_geom_to_hyperslab(config[\"geometry_file\"])\n    else:\n        calibrated_data = data\n        geometry_filename = config[\"geometry_file\"]\n\n    # PF8 processing\n    PF8Config.set_geometry_from_file(geometry_filename)\n    pf8 = PF8(PF8Config)\n    peak_list = pf8.get_peaks_pf8(data=calibrated_data)\n\n    if peak_list[\"num_peaks\"] &gt; config[\"pf8\"][\"min_num_peaks\"]:\n        result = calculate_detector_center_on_a_frame(\n            calibrated_data, memory_cell_id, config, PF8Config\n        )\n    else:\n        result = [0, 0, 0, 0, 0]\n    return result\n</code></pre>"},{"location":"reference/main/#beambusters.main.run_centering_parallel","title":"<code>run_centering_parallel(input, path_to_config)</code>","text":"<p>Process one HDF5 file. Results will be appended to the HDF5 file given as input.</p> <p>Attributes:</p> Name Type Description <code>input</code> <code>str</code> <p>Full path to the HDF5 file.</p> <code>path_to_config</code> <code>str</code> <p>Path to the YAML configuration file.</p> Source code in <code>beambusters/main.py</code> <pre><code>@app.command(\"run_centering\")\ndef run_centering_parallel(input: str, path_to_config: str):\n\n    \"\"\"\n    Process one HDF5 file. Results will be appended to the HDF5 file given as input.\n\n    Attributes:\n        input (str): Full path to the HDF5 file.\n\n        path_to_config (str): Path to the YAML configuration file.\n    \"\"\"\n    config = settings.read(path_to_config)\n    BeambustersParam = settings.parse(config)\n    files = open(input, \"r\")\n    paths = files.readlines()\n    files.close()\n\n    if len(paths[0][:-1].split(\" //\")) == 1:\n        list_name = input\n        events_list_file = (\n            f\"{list_name.split('.')[0]}_events.lst{list_name.split('.lst')[-1]}\"\n        )\n        list_events(list_name, events_list_file, config[\"geometry_file\"])\n        files = open(events_list_file, \"r\")\n        paths = files.readlines()\n        files.close()\n\n    output_file, frame_number = paths[0].split(\" //\")\n    filename = output_file\n\n    geometry_txt = open(config[\"geometry_file\"], \"r\").readlines()\n    data_hdf5_path = [\n        x.split(\" = \")[-1][:-1] for x in geometry_txt if x.split(\" = \")[0] == \"data\"\n    ][0]\n\n    ## Initialize results array\n    number_of_frames = len(paths)\n    refined_center_flag = np.zeros(number_of_frames, dtype=np.int16)\n    pre_centering_flag = np.zeros(number_of_frames, dtype=np.int16)\n    hits = np.zeros((number_of_frames,), dtype=np.int16)\n    detector_shift_x_in_mm = np.zeros((number_of_frames,), dtype=np.float32)\n    detector_shift_y_in_mm = np.zeros((number_of_frames,), dtype=np.float32)\n\n    with h5py.File(f\"{filename}\", \"r\") as f:\n        data_shape = f[data_hdf5_path].shape\n    number_of_events = data_shape[0]\n    rest = number_of_events % config[\"chunks\"]\n    results = []\n\n    for i in range(0, number_of_events - rest, config[\"chunks\"]):\n        with h5py.File(f\"{filename}\", \"r\") as f:\n            events = np.array(\n                f[data_hdf5_path][i : i + config[\"chunks\"]], dtype=np.int32\n            )\n            if config[\"burst_mode\"][\"is_active\"]:\n                memory_cells_id = np.array(\n                    f[config[\"burst_mode\"][\"storage_cell_hdf5_path\"]][\n                        i : i + config[\"chunks\"]\n                    ],\n                    dtype=np.int32,\n                )\n            else:\n                memory_cells_id = np.zeros(config[\"chunks\"], dtype=np.int32)\n\n            # Use multiprocessing Pool for parallel processing\n            args = [\n                [event, memory_cells_id[index], paths[i + index], config]\n                for index, event in enumerate(events)\n            ]\n            with Pool(config[\"number_of_processors\"]) as p:\n                partial_results = p.map(process_file, args)\n            ## Join with results\n        results = [*results, *partial_results]\n\n    i = number_of_events - rest\n    with h5py.File(f\"{filename}\", \"r\") as f:\n        events = np.array(f[data_hdf5_path][i:number_of_events], dtype=np.int32)\n        if config[\"burst_mode\"][\"is_active\"]:\n            memory_cells_id = np.array(\n                f[config[\"burst_mode\"][\"storage_cell_hdf5_path\"]][i:number_of_events],\n                dtype=np.int32,\n            )\n        else:\n            memory_cells_id = np.zeros(rest, dtype=np.int32)\n        # Use multiprocessing Pool for parallel processing\n        args = [\n            [event, memory_cells_id[index], paths[index], config]\n            for index, event in enumerate(events)\n        ]\n        with Pool(config[\"number_of_processors\"]) as p:\n            partial_results = p.map(process_file, args)\n\n    results = [*results, *partial_results]\n\n    ## Rearrange results arrays\n    for index, i in enumerate(results):\n        (\n            detector_shift_x_in_mm[index],\n            detector_shift_y_in_mm[index],\n            hits[index],\n            pre_centering_flag[index],\n            refined_center_flag[index],\n        ) = i\n\n    with h5py.File(output_file, \"a\") as f:\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/detector_shift_x_in_mm\",\n            data=detector_shift_x_in_mm,\n        )\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/detector_shift_y_in_mm\",\n            data=detector_shift_y_in_mm,\n        )\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/refined_center_flag\",\n            data=refined_center_flag,\n        )\n        f.create_dataset(\n            f\"{config['output_hdf5_root_path']}/pre_centering_flag\",\n            data=pre_centering_flag,\n        )\n        f.create_dataset(f\"{config['output_hdf5_root_path']}/hit\", data=hits)\n</code></pre>"}]}