{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Beambusters.","title":"Home"},{"location":"api/","text":"Documentation Welcome to Beambusters Documentation. This documentation is generated by MkDocs and mkdocstrings. API Reference main () This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help Source code in beambusters/main.py 192 193 194 195 196 197 198 199 200 201 202 @app . callback () def main (): \"\"\" This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help \"\"\" process_file ( args ) Process one event. Attributes: Name Type Description args list List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: Name Type Description results list Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. Source code in beambusters/main.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def process_file ( args : list ) -> list : \"\"\" Process one event. Attributes: args (list): List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. \"\"\" data , memory_cell_id , path , config = args filename , frame_number = path . split ( \" //\" ) print ( f \"Image filename: { filename } \" ) print ( f \"Event: // { frame_number } \" ) frame_number = int ( frame_number ) PF8Config = settings . get_pf8_info ( config ) # Transform vds to hyperslab if len ( data . shape ) > 2 and config [ \"vds_format\" ]: calibrated_data = expand_data_to_hyperslab ( data = data , data_format = config [ \"vds_id\" ] ) geometry_filename = ( config [ \"geometry_file\" ] . split ( \".geom\" )[ 0 ] + \"_hyperslab.geom\" ) if not os . path . exists ( geometry_filename ): geometry_filename = translate_geom_to_hyperslab ( config [ \"geometry_file\" ]) else : calibrated_data = data geometry_filename = config [ \"geometry_file\" ] # PF8 processing PF8Config . set_geometry_from_file ( geometry_filename ) pf8 = PF8 ( PF8Config ) peak_list = pf8 . get_peaks_pf8 ( data = calibrated_data ) if peak_list [ \"num_peaks\" ] > config [ \"pf8\" ][ \"min_num_peaks\" ]: result = calculate_detector_center_on_a_frame ( calibrated_data , memory_cell_id , config , PF8Config ) else : result = [ 0 , 0 , 0 , 0 , 0 ] return result run_centering_parallel ( input , path_to_config ) Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: Name Type Description input str Full path to the HDF5 file. path_to_config str Path to the YAML configuration file. Source code in beambusters/main.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 @app . command ( \"run_centering\" ) def run_centering_parallel ( input : str , path_to_config : str ): \"\"\" Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: input (str): Full path to the HDF5 file. path_to_config (str): Path to the YAML configuration file. \"\"\" config = settings . read ( path_to_config ) BeambustersParam = settings . parse ( config ) files = open ( input , \"r\" ) paths = files . readlines () files . close () if len ( paths [ 0 ][: - 1 ] . split ( \" //\" )) == 1 : list_name = input events_list_file = ( f \" { list_name . split ( '.' )[ 0 ] } _events.lst { list_name . split ( '.lst' )[ - 1 ] } \" ) list_events ( list_name , events_list_file , config [ \"geometry_file\" ]) files = open ( events_list_file , \"r\" ) paths = files . readlines () files . close () output_file , frame_number = paths [ 0 ] . split ( \" //\" ) filename = output_file geometry_txt = open ( config [ \"geometry_file\" ], \"r\" ) . readlines () data_hdf5_path = [ x . split ( \" = \" )[ - 1 ][: - 1 ] for x in geometry_txt if x . split ( \" = \" )[ 0 ] == \"data\" ][ 0 ] ## Initialize results array number_of_frames = len ( paths ) refined_center_flag = np . zeros ( number_of_frames , dtype = np . int16 ) pre_centering_flag = np . zeros ( number_of_frames , dtype = np . int16 ) hits = np . zeros (( number_of_frames ,), dtype = np . int16 ) detector_shift_x_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) detector_shift_y_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) with h5py . File ( f \" { filename } \" , \"r\" ) as f : data_shape = f [ data_hdf5_path ] . shape number_of_events = data_shape [ 0 ] rest = number_of_events % config [ \"chunks\" ] results = [] for i in range ( 0 , number_of_events - rest , config [ \"chunks\" ]): with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : i + config [ \"chunks\" ]], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : i + config [ \"chunks\" ] ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( config [ \"chunks\" ], dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ i + index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) ## Join with results results = [ * results , * partial_results ] i = number_of_events - rest with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : number_of_events ], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : number_of_events ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( rest , dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) results = [ * results , * partial_results ] ## Rearrange results arrays for index , i in enumerate ( results ): ( detector_shift_x_in_mm [ index ], detector_shift_y_in_mm [ index ], hits [ index ], pre_centering_flag [ index ], refined_center_flag [ index ], ) = i with h5py . File ( output_file , \"a\" ) as f : f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_x_in_mm\" , data = detector_shift_x_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_y_in_mm\" , data = detector_shift_y_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /refined_center_flag\" , data = refined_center_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /pre_centering_flag\" , data = pre_centering_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /hit\" , data = hits ) calculate_detector_center_on_a_frame ( calibrated_data , memory_cell_id , config , PF8Config ) Calculate the detector center on a frame. Attributes: Name Type Description calibrated_data array Data in which the center determination will be performed. memory_cell_id int Memory cell id of the frame, only necessary when operating in storage cell mode. config dict Configuration dictionary containing the beambusters configuration parameters. PF8Config dict Configuration dictionary containing peakfinder8 parameters. Returns: Name Type Description results list Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. Source code in beambusters/algorithms.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def calculate_detector_center_on_a_frame ( calibrated_data : np . array , memory_cell_id : int , config : dict , PF8Config : dict ) -> list : \"\"\" Calculate the detector center on a frame. Attributes: calibrated_data (np.array): Data in which the center determination will be performed. memory_cell_id (int): Memory cell id of the frame, only necessary when operating in storage cell mode. config (dict): Configuration dictionary containing the beambusters configuration parameters. PF8Config (dict): Configuration dictionary containing peakfinder8 parameters. Returns: results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. \"\"\" plots_info = { \"filename\" : \"\" , \"folder_name\" : \"\" , \"root_path\" : \"\" } config [ \"plots_flag\" ] = False if \"center_of_mass\" not in config [ \"skip_centering_methods\" ]: center_of_mass_method = CenterOfMass ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_center_of_mass = center_of_mass_method ( data = calibrated_data ) else : detector_center_from_center_of_mass = [ - 1 , - 1 ] if \"circle_detection\" not in config [ \"skip_centering_methods\" ]: for rank in range ( config [ \"hough\" ][ \"maximum_rank\" ]): config [ \"hough_rank\" ] = rank circle_detection_method = CircleDetection ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_circle_detection = circle_detection_method ( data = calibrated_data ) ## Calculate distance from the calculated center to the reference point in each axis distance_in_x = math . sqrt ( ( detector_center_from_circle_detection [ 0 ] - config [ \"reference_center\" ][ \"x\" ] ) ** 2 ) distance_in_y = math . sqrt ( ( detector_center_from_circle_detection [ 1 ] - config [ \"reference_center\" ][ \"y\" ] ) ** 2 ) if ( distance_in_x < config [ \"hough\" ][ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"hough\" ][ \"outlier_distance\" ][ \"y\" ] ): break ## Check for the case where rank reached the maximum value and the detector center is not within the allowed region else : detector_center_from_circle_detection = [ - 1 , - 1 ] else : detector_center_from_circle_detection = [ - 1 , - 1 ] if \"minimize_peak_fwhm\" not in config [ \"skip_centering_methods\" ]: minimize_peak_fwhm_method = MinimizePeakFWHM ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_minimize_peak_fwhm = minimize_peak_fwhm_method ( data = calibrated_data ) else : detector_center_from_minimize_peak_fwhm = [ - 1 , - 1 ] ## Define the initial_guess initial_guess = [ - 1 , - 1 ] pre_centering_flag = 0 is_a_hit = 0 refined_center_flag = 0 if config [ \"centering_method_for_initial_guess\" ] == \"center_of_mass\" : calculated_detector_center = detector_center_from_center_of_mass distance_in_x = math . sqrt ( ( calculated_detector_center [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt ( ( calculated_detector_center [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): pre_centering_flag = 1 initial_guess = detector_center_from_center_of_mass elif config [ \"centering_method_for_initial_guess\" ] == \"circle_detection\" : calculated_detector_center = detector_center_from_circle_detection distance_in_x = math . sqrt ( ( calculated_detector_center [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt ( ( calculated_detector_center [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): pre_centering_flag = 1 initial_guess = detector_center_from_circle_detection elif config [ \"centering_method_for_initial_guess\" ] == \"minimize_peak_fwhm\" : calculated_detector_center = detector_center_from_minimize_peak_fwhm distance_in_x = math . sqrt ( ( calculated_detector_center [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt ( ( calculated_detector_center [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): pre_centering_flag = 1 initial_guess = detector_center_from_minimize_peak_fwhm elif config [ \"centering_method_for_initial_guess\" ] == \"manual_input\" : initial_guess = [ config [ \"manual_input\" ][ f \" { memory_cell_id } \" ][ \"x\" ], config [ \"manual_input\" ][ f \" { memory_cell_id } \" ][ \"y\" ], ] # If the method chosen didn't converge change to the detector center from the geometry file if initial_guess [ 0 ] == - 1 and initial_guess [ 1 ] == - 1 : initial_guess = PF8Config . detector_center_from_geom # Force center override the initial guess calculated to coordinates defined in config if config [ \"force_center\" ][ \"state\" ]: if config [ \"force_center\" ][ \"anchor_x\" ]: initial_guess [ 0 ] = config [ \"force_center\" ][ \"x\" ] if config [ \"force_center\" ][ \"anchor_y\" ]: initial_guess [ 1 ] = config [ \"force_center\" ][ \"y\" ] # Compares if the calculated center is within the outlier distance in each axis distance_in_x = math . sqrt (( initial_guess [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt (( initial_guess [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) # Start refine the detector center by FriedelPairs center_is_refined = False if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): ## Ready for detector center refinement PF8Config . update_pixel_maps ( initial_guess [ 0 ] - PF8Config . detector_center_from_geom [ 0 ], initial_guess [ 1 ] - PF8Config . detector_center_from_geom [ 1 ], ) pf8 = PF8 ( PF8Config ) peak_list = pf8 . get_peaks_pf8 ( data = calibrated_data ) if config [ \"vds_format\" ] and config [ \"vds_id\" ] == \"vds_spb_jf4m\" : geometry_filename = ( config [ \"geometry_file\" ] . split ( \".geom\" )[ 0 ] + \"_hyperslab.geom\" ) else : geometry_filename = config [ \"geometry_file\" ] PF8Config . set_geometry_from_file ( geometry_filename ) if ( \"friedel_pairs\" not in config [ \"skip_centering_methods\" ] and peak_list [ \"num_peaks\" ] > config [ \"pf8\" ][ \"min_num_peaks\" ] ): is_a_hit = 1 friedel_pairs_method = FriedelPairs ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_friedel_pairs = friedel_pairs_method ( data = calibrated_data , initial_guess = initial_guess ) if centering_converged ( detector_center_from_friedel_pairs ): center_is_refined = True else : center_is_refined = False else : center_is_refined = False ## Refined detector center assignement if center_is_refined : refined_detector_center = detector_center_from_friedel_pairs refined_center_flag = 1 else : refined_detector_center = initial_guess beam_position_shift_in_pixels = [ refined_detector_center [ x ] - PF8Config . detector_center_from_geom [ x ] for x in range ( 2 ) ] detector_shift_in_mm = [ np . round ( - 1 * x * 1e3 / PF8Config . pixel_resolution , 4 ) for x in beam_position_shift_in_pixels ] detector_shift_x_in_mm = detector_shift_in_mm [ 0 ] detector_shift_y_in_mm = detector_shift_in_mm [ 1 ] return [ detector_shift_x_in_mm , detector_shift_y_in_mm , is_a_hit , pre_centering_flag , refined_center_flag , ]","title":"Documentation"},{"location":"api/#documentation","text":"Welcome to Beambusters Documentation. This documentation is generated by MkDocs and mkdocstrings.","title":"Documentation"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#beambusters.main.main","text":"This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help Source code in beambusters/main.py 192 193 194 195 196 197 198 199 200 201 202 @app . callback () def main (): \"\"\" This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help \"\"\"","title":"main"},{"location":"api/#beambusters.main.process_file","text":"Process one event. Attributes: Name Type Description args list List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: Name Type Description results list Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. Source code in beambusters/main.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def process_file ( args : list ) -> list : \"\"\" Process one event. Attributes: args (list): List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. \"\"\" data , memory_cell_id , path , config = args filename , frame_number = path . split ( \" //\" ) print ( f \"Image filename: { filename } \" ) print ( f \"Event: // { frame_number } \" ) frame_number = int ( frame_number ) PF8Config = settings . get_pf8_info ( config ) # Transform vds to hyperslab if len ( data . shape ) > 2 and config [ \"vds_format\" ]: calibrated_data = expand_data_to_hyperslab ( data = data , data_format = config [ \"vds_id\" ] ) geometry_filename = ( config [ \"geometry_file\" ] . split ( \".geom\" )[ 0 ] + \"_hyperslab.geom\" ) if not os . path . exists ( geometry_filename ): geometry_filename = translate_geom_to_hyperslab ( config [ \"geometry_file\" ]) else : calibrated_data = data geometry_filename = config [ \"geometry_file\" ] # PF8 processing PF8Config . set_geometry_from_file ( geometry_filename ) pf8 = PF8 ( PF8Config ) peak_list = pf8 . get_peaks_pf8 ( data = calibrated_data ) if peak_list [ \"num_peaks\" ] > config [ \"pf8\" ][ \"min_num_peaks\" ]: result = calculate_detector_center_on_a_frame ( calibrated_data , memory_cell_id , config , PF8Config ) else : result = [ 0 , 0 , 0 , 0 , 0 ] return result","title":"process_file"},{"location":"api/#beambusters.main.run_centering_parallel","text":"Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: Name Type Description input str Full path to the HDF5 file. path_to_config str Path to the YAML configuration file. Source code in beambusters/main.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 @app . command ( \"run_centering\" ) def run_centering_parallel ( input : str , path_to_config : str ): \"\"\" Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: input (str): Full path to the HDF5 file. path_to_config (str): Path to the YAML configuration file. \"\"\" config = settings . read ( path_to_config ) BeambustersParam = settings . parse ( config ) files = open ( input , \"r\" ) paths = files . readlines () files . close () if len ( paths [ 0 ][: - 1 ] . split ( \" //\" )) == 1 : list_name = input events_list_file = ( f \" { list_name . split ( '.' )[ 0 ] } _events.lst { list_name . split ( '.lst' )[ - 1 ] } \" ) list_events ( list_name , events_list_file , config [ \"geometry_file\" ]) files = open ( events_list_file , \"r\" ) paths = files . readlines () files . close () output_file , frame_number = paths [ 0 ] . split ( \" //\" ) filename = output_file geometry_txt = open ( config [ \"geometry_file\" ], \"r\" ) . readlines () data_hdf5_path = [ x . split ( \" = \" )[ - 1 ][: - 1 ] for x in geometry_txt if x . split ( \" = \" )[ 0 ] == \"data\" ][ 0 ] ## Initialize results array number_of_frames = len ( paths ) refined_center_flag = np . zeros ( number_of_frames , dtype = np . int16 ) pre_centering_flag = np . zeros ( number_of_frames , dtype = np . int16 ) hits = np . zeros (( number_of_frames ,), dtype = np . int16 ) detector_shift_x_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) detector_shift_y_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) with h5py . File ( f \" { filename } \" , \"r\" ) as f : data_shape = f [ data_hdf5_path ] . shape number_of_events = data_shape [ 0 ] rest = number_of_events % config [ \"chunks\" ] results = [] for i in range ( 0 , number_of_events - rest , config [ \"chunks\" ]): with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : i + config [ \"chunks\" ]], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : i + config [ \"chunks\" ] ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( config [ \"chunks\" ], dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ i + index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) ## Join with results results = [ * results , * partial_results ] i = number_of_events - rest with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : number_of_events ], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : number_of_events ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( rest , dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) results = [ * results , * partial_results ] ## Rearrange results arrays for index , i in enumerate ( results ): ( detector_shift_x_in_mm [ index ], detector_shift_y_in_mm [ index ], hits [ index ], pre_centering_flag [ index ], refined_center_flag [ index ], ) = i with h5py . File ( output_file , \"a\" ) as f : f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_x_in_mm\" , data = detector_shift_x_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_y_in_mm\" , data = detector_shift_y_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /refined_center_flag\" , data = refined_center_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /pre_centering_flag\" , data = pre_centering_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /hit\" , data = hits )","title":"run_centering_parallel"},{"location":"api/#beambusters.algorithms.calculate_detector_center_on_a_frame","text":"Calculate the detector center on a frame. Attributes: Name Type Description calibrated_data array Data in which the center determination will be performed. memory_cell_id int Memory cell id of the frame, only necessary when operating in storage cell mode. config dict Configuration dictionary containing the beambusters configuration parameters. PF8Config dict Configuration dictionary containing peakfinder8 parameters. Returns: Name Type Description results list Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. Source code in beambusters/algorithms.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def calculate_detector_center_on_a_frame ( calibrated_data : np . array , memory_cell_id : int , config : dict , PF8Config : dict ) -> list : \"\"\" Calculate the detector center on a frame. Attributes: calibrated_data (np.array): Data in which the center determination will be performed. memory_cell_id (int): Memory cell id of the frame, only necessary when operating in storage cell mode. config (dict): Configuration dictionary containing the beambusters configuration parameters. PF8Config (dict): Configuration dictionary containing peakfinder8 parameters. Returns: results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. \"\"\" plots_info = { \"filename\" : \"\" , \"folder_name\" : \"\" , \"root_path\" : \"\" } config [ \"plots_flag\" ] = False if \"center_of_mass\" not in config [ \"skip_centering_methods\" ]: center_of_mass_method = CenterOfMass ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_center_of_mass = center_of_mass_method ( data = calibrated_data ) else : detector_center_from_center_of_mass = [ - 1 , - 1 ] if \"circle_detection\" not in config [ \"skip_centering_methods\" ]: for rank in range ( config [ \"hough\" ][ \"maximum_rank\" ]): config [ \"hough_rank\" ] = rank circle_detection_method = CircleDetection ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_circle_detection = circle_detection_method ( data = calibrated_data ) ## Calculate distance from the calculated center to the reference point in each axis distance_in_x = math . sqrt ( ( detector_center_from_circle_detection [ 0 ] - config [ \"reference_center\" ][ \"x\" ] ) ** 2 ) distance_in_y = math . sqrt ( ( detector_center_from_circle_detection [ 1 ] - config [ \"reference_center\" ][ \"y\" ] ) ** 2 ) if ( distance_in_x < config [ \"hough\" ][ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"hough\" ][ \"outlier_distance\" ][ \"y\" ] ): break ## Check for the case where rank reached the maximum value and the detector center is not within the allowed region else : detector_center_from_circle_detection = [ - 1 , - 1 ] else : detector_center_from_circle_detection = [ - 1 , - 1 ] if \"minimize_peak_fwhm\" not in config [ \"skip_centering_methods\" ]: minimize_peak_fwhm_method = MinimizePeakFWHM ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_minimize_peak_fwhm = minimize_peak_fwhm_method ( data = calibrated_data ) else : detector_center_from_minimize_peak_fwhm = [ - 1 , - 1 ] ## Define the initial_guess initial_guess = [ - 1 , - 1 ] pre_centering_flag = 0 is_a_hit = 0 refined_center_flag = 0 if config [ \"centering_method_for_initial_guess\" ] == \"center_of_mass\" : calculated_detector_center = detector_center_from_center_of_mass distance_in_x = math . sqrt ( ( calculated_detector_center [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt ( ( calculated_detector_center [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): pre_centering_flag = 1 initial_guess = detector_center_from_center_of_mass elif config [ \"centering_method_for_initial_guess\" ] == \"circle_detection\" : calculated_detector_center = detector_center_from_circle_detection distance_in_x = math . sqrt ( ( calculated_detector_center [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt ( ( calculated_detector_center [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): pre_centering_flag = 1 initial_guess = detector_center_from_circle_detection elif config [ \"centering_method_for_initial_guess\" ] == \"minimize_peak_fwhm\" : calculated_detector_center = detector_center_from_minimize_peak_fwhm distance_in_x = math . sqrt ( ( calculated_detector_center [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt ( ( calculated_detector_center [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): pre_centering_flag = 1 initial_guess = detector_center_from_minimize_peak_fwhm elif config [ \"centering_method_for_initial_guess\" ] == \"manual_input\" : initial_guess = [ config [ \"manual_input\" ][ f \" { memory_cell_id } \" ][ \"x\" ], config [ \"manual_input\" ][ f \" { memory_cell_id } \" ][ \"y\" ], ] # If the method chosen didn't converge change to the detector center from the geometry file if initial_guess [ 0 ] == - 1 and initial_guess [ 1 ] == - 1 : initial_guess = PF8Config . detector_center_from_geom # Force center override the initial guess calculated to coordinates defined in config if config [ \"force_center\" ][ \"state\" ]: if config [ \"force_center\" ][ \"anchor_x\" ]: initial_guess [ 0 ] = config [ \"force_center\" ][ \"x\" ] if config [ \"force_center\" ][ \"anchor_y\" ]: initial_guess [ 1 ] = config [ \"force_center\" ][ \"y\" ] # Compares if the calculated center is within the outlier distance in each axis distance_in_x = math . sqrt (( initial_guess [ 0 ] - config [ \"reference_center\" ][ \"x\" ]) ** 2 ) distance_in_y = math . sqrt (( initial_guess [ 1 ] - config [ \"reference_center\" ][ \"y\" ]) ** 2 ) # Start refine the detector center by FriedelPairs center_is_refined = False if ( distance_in_x < config [ \"outlier_distance\" ][ \"x\" ] and distance_in_y < config [ \"outlier_distance\" ][ \"y\" ] ): ## Ready for detector center refinement PF8Config . update_pixel_maps ( initial_guess [ 0 ] - PF8Config . detector_center_from_geom [ 0 ], initial_guess [ 1 ] - PF8Config . detector_center_from_geom [ 1 ], ) pf8 = PF8 ( PF8Config ) peak_list = pf8 . get_peaks_pf8 ( data = calibrated_data ) if config [ \"vds_format\" ] and config [ \"vds_id\" ] == \"vds_spb_jf4m\" : geometry_filename = ( config [ \"geometry_file\" ] . split ( \".geom\" )[ 0 ] + \"_hyperslab.geom\" ) else : geometry_filename = config [ \"geometry_file\" ] PF8Config . set_geometry_from_file ( geometry_filename ) if ( \"friedel_pairs\" not in config [ \"skip_centering_methods\" ] and peak_list [ \"num_peaks\" ] > config [ \"pf8\" ][ \"min_num_peaks\" ] ): is_a_hit = 1 friedel_pairs_method = FriedelPairs ( config = config , PF8Config = PF8Config , plots_info = plots_info ) detector_center_from_friedel_pairs = friedel_pairs_method ( data = calibrated_data , initial_guess = initial_guess ) if centering_converged ( detector_center_from_friedel_pairs ): center_is_refined = True else : center_is_refined = False else : center_is_refined = False ## Refined detector center assignement if center_is_refined : refined_detector_center = detector_center_from_friedel_pairs refined_center_flag = 1 else : refined_detector_center = initial_guess beam_position_shift_in_pixels = [ refined_detector_center [ x ] - PF8Config . detector_center_from_geom [ x ] for x in range ( 2 ) ] detector_shift_in_mm = [ np . round ( - 1 * x * 1e3 / PF8Config . pixel_resolution , 4 ) for x in beam_position_shift_in_pixels ] detector_shift_x_in_mm = detector_shift_in_mm [ 0 ] detector_shift_y_in_mm = detector_shift_in_mm [ 1 ] return [ detector_shift_x_in_mm , detector_shift_y_in_mm , is_a_hit , pre_centering_flag , refined_center_flag , ]","title":"calculate_detector_center_on_a_frame"},{"location":"example/config/","text":"chunks: Number of frames in a chunk for parallel processing number_of_processors: Number of processors to use in parallel processing vds_format: True if the file is saved in VDS format. Type: bool vds_id: Identification of which detector is being used. Currently it is supported \"vds_spb_jf4m\" and \"generic\". Type: str burst_mode: Indicate if the detector is on burst mode. state: Burst/storage cell mode (true) or single cell mode (false). Type: bool. storage_cell_hdf5_path: Absolute HDF5 path to the storage cell id per frame. Type: str plots: flag: Indicate if plots should be saved in intermediate steps (true) or not (false). Type: bool. maximum_number_of_frames: Number of frames to save plots. Type: int file_name: The plots file name for saving. Type: str. folder_name: The plots folder name for saving. Type: str. root_path: Absolute path for the root directory for saving. Plots final state is /root_path/folder_name/ /file_name_ .png. Type: str. value_auto: Control the automatic intensity adjustment of plots level (true). The normalization used is in logarithmic scale. Type: bool. value_min: If value_auto is false, minimum value of the intensity level should be passed. The normalization used is in logarithmic scale. Type: int. value_max: If value_auto is false, maximum value of the intensity level should be passed. The normalization used is in logarithmic scale. Type: int. axis_lim_auto: Control the automatic axis limits of the plots (true). Type: bool. xlim_min: If axis_lim_auto is false, minimum coordinate of the x axis should be passed. Type: int. xlim_max: If axis_lim_auto is false, maximum coordinate of the x axis should be passed. Type: int. ylim_min: If axis_lim_auto is false, minimum coordinate of the y axis should be passed. Type: int. ylim_max: If axis_lim_auto is false, maximum coordinate of the y axis should be passed. Type: int. color_map: Colormap preference for the plots, for example: viridis. Type: str. marker_size: Scatter marker size of center coordinates. Type: float starting_frame: Change the index of the starting frame, it will jump the first n images of the container file. Type: int. force_center: Anchor the initial guess to a fixed point, if enabled this option will override other bblib pre-centering methods. state: Turn force mode on (true) or off (false). Type: bool. anchor_x: Turn force mode on (true) or off (false) for the x-axis. Type: bool. anchor_y: Turn force mode on (true) or off (false) for the y-axis . Type: bool. x: Initial guess pixel coordinates in x of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int. y: Initial guess pixel coordinates in y of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int. search_radius: Search radius used in the FriedelPairs bblib method. Type: float pf8: peakfinder8 paratemers for Bragg peaks search. For more information, see: https://www.desy.de/~barty/cheetah/Cheetah/SFX_hitfinding.html max_num_peaks: Maximum number of peaks. Type: int adc_threshold: Arbitrary detector counts (ADC) threshold. Type: int minimum_snr: Minimum signal-to-noise ratio (SNR). Type: float min_pixel_count: Minimum number of pixels to consider a peak. Type: int max_pixel_count: Maximum number of pixels to consider a peak. Type: int local_bg_radius: Radius of the peaks local background, in pixels. Type: int min_res: Minimum resolution region, in pixels. Type: int max_res: Maximum resolution region, in pixels. Type: int offset: Add an offset to the calculated center. The offset will be applied in the end of every bblib centering method. Set offsets to +0.5 in x and y to shift the detector center coordinates from pixel indices to the pixel center, as expected for CrystFEL. x: Offset in x direction, in pixels. Type: int y: Offset in y direction, in pixels. Type: int peak_region: Defines the approximate background peak distance from the center of the diffraction pattern, in pixels. This option is used in CircleDetection bblib pre-centering methods. min: Minimum distance, in pixels, of the background peak to the center of the diffraction pattern. Type: int max: Maximum distance, in pixels, of the background peak to the center of the diffraction pattern. Type: int outlier_distance: Don't refine the detector center with FriedelPairs method if the distance from the initial_guess (in a certain axis) to the reference_center coordinates is bigger than the outlier_distance. x: Outlier distance in x y: Outlier distance in y reference_center: Reference center of the diffraction pattern to filter outliers in the initial_guess calculation x: Reference center pixel coordinates in x of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int y: Reference center pixel coordinates in y of the assembled data, i.e. image stored in a single array with the detector panels' geometric transformations applied, according to CrystFEL referential convention. Type: int canny: Controls skimage.feature.canny function, used in the CircleDetection bblib method. For more information, see: https://scikit-image.org/docs/stable/auto_examples/edges/plot_circular_elliptical_hough_transform.html sigma: Standard deviation of the Gaussian filter, used in the Canny function. Usually, 3 is good. Type: float low_threshold: Lower bound for hysteresis thresholding (linking edges), as quantiles of the edge magnitude image. Threshold must be in the range [0, 1). Usually, 0.9 is good. Type: float high_threshold: Upper bound for hysteresis thresholding (linking edges), as quantiles of the edge magnitude images. Threshold must be in the range [0, 1). Usually, 0.99 is good. Type: float hough: maximum_rank: Evaluate the ranked solutions of Hough transform output until the maximum ranked position. outlier_distance: If the ranked solution (from the most voted to the less voted) is within the outlier shift in x and y this solution is chosen as the detector center. x: Outlier shift in the x-axis y: Outlier shift in the y-axis centering_method_for_initial_guess: Choose the bblib pre-centering method for the initial_guess assignment. Options: 'center_of_mass' or 'circle_detection'. Type: str bragg_peaks_positions_for_center_of_mass_calculation: Choose if Bragg peaks should be masked out (0) from the image in the CenterOfMass bblib method, or use only the Bragg peaks (1), or use the image as it is (-1). Type: int pixels_for_mask_of_bragg_peaks: Radius of Bragg peaks, in pixels. Used in the bblib pre-centering methods. Type: int skip_centering_methods: List of bblib pre-centering methods you don't want to be executed. Options: 'center_of_mass', 'circle_detection' or 'friedel_pairs'. Type: List[str] - Method label you want to skip. Type: str polarization: Configure the polarization correction before refining the center in the FridelPairs bblib method. apply_polarization_correction: Aoply polarization correction (true) or not (false). Type: bool axis: Polarization axis direction. Options: 'x' and 'y', as defined by the CrystFEL referential convention. Type: str value: Polarization fraction in the axis direction. Type: float","title":"Config"},{"location":"reference/","text":"Beambusters Welcome to Beambusters Documentation. This documentation is generated by MkDocs and mkdocstrings.","title":"Beambusters"},{"location":"reference/#beambusters","text":"Welcome to Beambusters Documentation. This documentation is generated by MkDocs and mkdocstrings.","title":"Beambusters"},{"location":"reference/main/","text":"main CLI main () This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help Source code in beambusters/main.py 192 193 194 195 196 197 198 199 200 201 202 @app . callback () def main (): \"\"\" This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help \"\"\" process_file ( args ) Process one event. Attributes: Name Type Description args list List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: Name Type Description results list Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. Source code in beambusters/main.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def process_file ( args : list ) -> list : \"\"\" Process one event. Attributes: args (list): List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. \"\"\" data , memory_cell_id , path , config = args filename , frame_number = path . split ( \" //\" ) print ( f \"Image filename: { filename } \" ) print ( f \"Event: // { frame_number } \" ) frame_number = int ( frame_number ) PF8Config = settings . get_pf8_info ( config ) # Transform vds to hyperslab if len ( data . shape ) > 2 and config [ \"vds_format\" ]: calibrated_data = expand_data_to_hyperslab ( data = data , data_format = config [ \"vds_id\" ] ) geometry_filename = ( config [ \"geometry_file\" ] . split ( \".geom\" )[ 0 ] + \"_hyperslab.geom\" ) if not os . path . exists ( geometry_filename ): geometry_filename = translate_geom_to_hyperslab ( config [ \"geometry_file\" ]) else : calibrated_data = data geometry_filename = config [ \"geometry_file\" ] # PF8 processing PF8Config . set_geometry_from_file ( geometry_filename ) pf8 = PF8 ( PF8Config ) peak_list = pf8 . get_peaks_pf8 ( data = calibrated_data ) if peak_list [ \"num_peaks\" ] > config [ \"pf8\" ][ \"min_num_peaks\" ]: result = calculate_detector_center_on_a_frame ( calibrated_data , memory_cell_id , config , PF8Config ) else : result = [ 0 , 0 , 0 , 0 , 0 ] return result run_centering_parallel ( input , path_to_config ) Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: Name Type Description input str Full path to the HDF5 file. path_to_config str Path to the YAML configuration file. Source code in beambusters/main.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 @app . command ( \"run_centering\" ) def run_centering_parallel ( input : str , path_to_config : str ): \"\"\" Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: input (str): Full path to the HDF5 file. path_to_config (str): Path to the YAML configuration file. \"\"\" config = settings . read ( path_to_config ) BeambustersParam = settings . parse ( config ) files = open ( input , \"r\" ) paths = files . readlines () files . close () if len ( paths [ 0 ][: - 1 ] . split ( \" //\" )) == 1 : list_name = input events_list_file = ( f \" { list_name . split ( '.' )[ 0 ] } _events.lst { list_name . split ( '.lst' )[ - 1 ] } \" ) list_events ( list_name , events_list_file , config [ \"geometry_file\" ]) files = open ( events_list_file , \"r\" ) paths = files . readlines () files . close () output_file , frame_number = paths [ 0 ] . split ( \" //\" ) filename = output_file geometry_txt = open ( config [ \"geometry_file\" ], \"r\" ) . readlines () data_hdf5_path = [ x . split ( \" = \" )[ - 1 ][: - 1 ] for x in geometry_txt if x . split ( \" = \" )[ 0 ] == \"data\" ][ 0 ] ## Initialize results array number_of_frames = len ( paths ) refined_center_flag = np . zeros ( number_of_frames , dtype = np . int16 ) pre_centering_flag = np . zeros ( number_of_frames , dtype = np . int16 ) hits = np . zeros (( number_of_frames ,), dtype = np . int16 ) detector_shift_x_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) detector_shift_y_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) with h5py . File ( f \" { filename } \" , \"r\" ) as f : data_shape = f [ data_hdf5_path ] . shape number_of_events = data_shape [ 0 ] rest = number_of_events % config [ \"chunks\" ] results = [] for i in range ( 0 , number_of_events - rest , config [ \"chunks\" ]): with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : i + config [ \"chunks\" ]], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : i + config [ \"chunks\" ] ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( config [ \"chunks\" ], dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ i + index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) ## Join with results results = [ * results , * partial_results ] i = number_of_events - rest with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : number_of_events ], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : number_of_events ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( rest , dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) results = [ * results , * partial_results ] ## Rearrange results arrays for index , i in enumerate ( results ): ( detector_shift_x_in_mm [ index ], detector_shift_y_in_mm [ index ], hits [ index ], pre_centering_flag [ index ], refined_center_flag [ index ], ) = i with h5py . File ( output_file , \"a\" ) as f : f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_x_in_mm\" , data = detector_shift_x_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_y_in_mm\" , data = detector_shift_y_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /refined_center_flag\" , data = refined_center_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /pre_centering_flag\" , data = pre_centering_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /hit\" , data = hits )","title":"main CLI"},{"location":"reference/main/#main-cli","text":"","title":"main CLI"},{"location":"reference/main/#beambusters.main.main","text":"This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help Source code in beambusters/main.py 192 193 194 195 196 197 198 199 200 201 202 @app . callback () def main (): \"\"\" This module perfoms the pre-processing of serial crystallography data by determining the detector center shift in each frame. Beambusters support the VDS data format of the EuXFEL. Currently, only the Jungfrau 4M of the SPB/SFX instrument can be invoked when using the VDS data fromat. For more information, type the following command: beambusters run_centering --help \"\"\"","title":"main"},{"location":"reference/main/#beambusters.main.process_file","text":"Process one event. Attributes: Name Type Description args list List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: Name Type Description results list Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. Source code in beambusters/main.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def process_file ( args : list ) -> list : \"\"\" Process one event. Attributes: args (list): List of arguments containing the data event as np.ndarray, the memory cell id integer, the path of the event obtained from the input list, the configuration file path. Returns: results (list): Returns a list with the calculated detector center shit in x and y in mm, if it is a hit, if it was pre-centered and if the center was refined. \"\"\" data , memory_cell_id , path , config = args filename , frame_number = path . split ( \" //\" ) print ( f \"Image filename: { filename } \" ) print ( f \"Event: // { frame_number } \" ) frame_number = int ( frame_number ) PF8Config = settings . get_pf8_info ( config ) # Transform vds to hyperslab if len ( data . shape ) > 2 and config [ \"vds_format\" ]: calibrated_data = expand_data_to_hyperslab ( data = data , data_format = config [ \"vds_id\" ] ) geometry_filename = ( config [ \"geometry_file\" ] . split ( \".geom\" )[ 0 ] + \"_hyperslab.geom\" ) if not os . path . exists ( geometry_filename ): geometry_filename = translate_geom_to_hyperslab ( config [ \"geometry_file\" ]) else : calibrated_data = data geometry_filename = config [ \"geometry_file\" ] # PF8 processing PF8Config . set_geometry_from_file ( geometry_filename ) pf8 = PF8 ( PF8Config ) peak_list = pf8 . get_peaks_pf8 ( data = calibrated_data ) if peak_list [ \"num_peaks\" ] > config [ \"pf8\" ][ \"min_num_peaks\" ]: result = calculate_detector_center_on_a_frame ( calibrated_data , memory_cell_id , config , PF8Config ) else : result = [ 0 , 0 , 0 , 0 , 0 ] return result","title":"process_file"},{"location":"reference/main/#beambusters.main.run_centering_parallel","text":"Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: Name Type Description input str Full path to the HDF5 file. path_to_config str Path to the YAML configuration file. Source code in beambusters/main.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 @app . command ( \"run_centering\" ) def run_centering_parallel ( input : str , path_to_config : str ): \"\"\" Process one HDF5 file. Results will be appended to the HDF5 file given as input. Attributes: input (str): Full path to the HDF5 file. path_to_config (str): Path to the YAML configuration file. \"\"\" config = settings . read ( path_to_config ) BeambustersParam = settings . parse ( config ) files = open ( input , \"r\" ) paths = files . readlines () files . close () if len ( paths [ 0 ][: - 1 ] . split ( \" //\" )) == 1 : list_name = input events_list_file = ( f \" { list_name . split ( '.' )[ 0 ] } _events.lst { list_name . split ( '.lst' )[ - 1 ] } \" ) list_events ( list_name , events_list_file , config [ \"geometry_file\" ]) files = open ( events_list_file , \"r\" ) paths = files . readlines () files . close () output_file , frame_number = paths [ 0 ] . split ( \" //\" ) filename = output_file geometry_txt = open ( config [ \"geometry_file\" ], \"r\" ) . readlines () data_hdf5_path = [ x . split ( \" = \" )[ - 1 ][: - 1 ] for x in geometry_txt if x . split ( \" = \" )[ 0 ] == \"data\" ][ 0 ] ## Initialize results array number_of_frames = len ( paths ) refined_center_flag = np . zeros ( number_of_frames , dtype = np . int16 ) pre_centering_flag = np . zeros ( number_of_frames , dtype = np . int16 ) hits = np . zeros (( number_of_frames ,), dtype = np . int16 ) detector_shift_x_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) detector_shift_y_in_mm = np . zeros (( number_of_frames ,), dtype = np . float32 ) with h5py . File ( f \" { filename } \" , \"r\" ) as f : data_shape = f [ data_hdf5_path ] . shape number_of_events = data_shape [ 0 ] rest = number_of_events % config [ \"chunks\" ] results = [] for i in range ( 0 , number_of_events - rest , config [ \"chunks\" ]): with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : i + config [ \"chunks\" ]], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : i + config [ \"chunks\" ] ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( config [ \"chunks\" ], dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ i + index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) ## Join with results results = [ * results , * partial_results ] i = number_of_events - rest with h5py . File ( f \" { filename } \" , \"r\" ) as f : events = np . array ( f [ data_hdf5_path ][ i : number_of_events ], dtype = np . int32 ) if config [ \"burst_mode\" ][ \"is_active\" ]: memory_cells_id = np . array ( f [ config [ \"burst_mode\" ][ \"storage_cell_hdf5_path\" ]][ i : number_of_events ], dtype = np . int32 , ) else : memory_cells_id = np . zeros ( rest , dtype = np . int32 ) # Use multiprocessing Pool for parallel processing args = [ [ event , memory_cells_id [ index ], paths [ index ], config ] for index , event in enumerate ( events ) ] with Pool ( config [ \"number_of_processors\" ]) as p : partial_results = p . map ( process_file , args ) results = [ * results , * partial_results ] ## Rearrange results arrays for index , i in enumerate ( results ): ( detector_shift_x_in_mm [ index ], detector_shift_y_in_mm [ index ], hits [ index ], pre_centering_flag [ index ], refined_center_flag [ index ], ) = i with h5py . File ( output_file , \"a\" ) as f : f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_x_in_mm\" , data = detector_shift_x_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /detector_shift_y_in_mm\" , data = detector_shift_y_in_mm , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /refined_center_flag\" , data = refined_center_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /pre_centering_flag\" , data = pre_centering_flag , ) f . create_dataset ( f \" { config [ 'output_hdf5_root_path' ] } /hit\" , data = hits )","title":"run_centering_parallel"}]}